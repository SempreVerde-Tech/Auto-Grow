#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Adafruit_ADS1X15.h>
#include <EEPROM.h>
#include <avr/wdt.h>

// =========== CONSTANTES E DEFINIÇÕES ===========
// Pinagem
const uint8_t PIN_TEMP_SENSOR = 2;
const uint8_t PIN_BUTTON_MENU = 3;
const uint8_t PIN_BUTTON_DOWN = 4;
const uint8_t PIN_BUTTON_UP = 5;
const uint8_t PIN_MOSFET_TRIG = 6;
const uint8_t PIN_STATUS_LED = 7;

// Endereços EEPROM
const uint16_t EEPROM_CALIB_OFFSET = 0;
const uint16_t EEPROM_CALIB_SLOPE = 10;
const uint16_t EEPROM_PH_IDEAL = 20;

// Configurações do sistema
const float PH_MIN = 1.0;
const float PH_MAX = 13.0;
const float PH_DEFAULT = 7.0;
const float PH_VARIATION_THRESHOLD = 0.3;
const float PH_STABLE_THRESHOLD = 0.1;
const float CALIBRATION_TOLERANCE = 0.1;

// Tempos e intervalos (ms)
const unsigned long SENSOR_STABILIZE_TIME = 10000; // Reduzido para testes
const unsigned long MENU_TIMEOUT = 30000;
const unsigned long PUMP_RUN_TIME = 1000;
const unsigned long PUMP_COOLDOWN = 300000;
const unsigned long READING_INTERVAL = 1000;
const unsigned long AVERAGING_INTERVAL = 15000;
const unsigned long DISPLAY_UPDATE_INTERVAL = 500;

// Configurações ADS1115
const float ADS1115_CONVERSION_FACTOR = 0.0001875;

// Soluções de calibração
const float CALIB_SOLUTIONS[3] = {4.01, 7.01, 10.1};

// =========== VARIÁVEIS GLOBAIS ===========
// Objetos de hardware
LiquidCrystal_I2C lcd(0x27, 20, 4);
OneWire oneWire(PIN_TEMP_SENSOR);
DallasTemperature tempSensor(&oneWire);
Adafruit_ADS1115 ads1115;

// Estado do sistema
enum SystemState {
  BOOT,
  MONITORING,
  MAIN_MENU,
  SET_PH_MENU,
  CALIBRATE_MENU,
  CALIBRATE_1POINT_MENU,
  CALIBRATE_1POINT_SOLUTION,
  CALIBRATE_1POINT_MEASURING,
  TECH_MENU,
  RAW_VALUES,
  SENSOR_CHECK,
  RESTART_CONFIRM
};

SystemState currentState = BOOT;
unsigned long stateEntryTime = 0;

// Variáveis de medição
float currentPh = 7.0;
float instantPh = 7.0;
float currentTemp = 25.0;
float targetPh = PH_DEFAULT;

// Variáveis de calibração
float calibOffset = 2.5;
float calibSlope = 0.18;

// Controle de tempo
unsigned long lastButtonPress = 0;
unsigned long lastReadingTime = 0;
unsigned long lastAveragingTime = 0;
unsigned long lastPumpActivation = 0;
unsigned long lastDisplayUpdate = 0;

// Buffers de leitura
const uint8_t READINGS_BUFFER_SIZE = 15;
float phReadings[READINGS_BUFFER_SIZE];
uint8_t currentReadingIndex = 0;

// Controle de interface
uint8_t menuPosition = 0;
uint8_t subMenuPosition = 0;
bool needsRedraw = true;

// Status do sistema
bool isPumpRunning = false;
bool isLedOn = false;
bool phAdjustmentNeeded = false;

// =========== CONFIGURAÇÃO INICIAL ===========
void setup() {
  wdt_enable(WDTO_4S);
  
  // Inicialização de hardware
  pinMode(PIN_BUTTON_MENU, INPUT_PULLUP);
  pinMode(PIN_BUTTON_DOWN, INPUT_PULLUP);
  pinMode(PIN_BUTTON_UP, INPUT_PULLUP);
  pinMode(PIN_MOSFET_TRIG, OUTPUT);
  pinMode(PIN_STATUS_LED, OUTPUT);
  
  digitalWrite(PIN_MOSFET_TRIG, LOW);
  digitalWrite(PIN_STATUS_LED, LOW);
  
  // Inicialização de comunicações
  Serial.begin(9600);
  Wire.begin();
  lcd.begin(20, 4);
  lcd.backlight();
  lcd.clear();
  
  // Inicialização de sensores
  tempSensor.begin();
  if (!ads1115.begin(0x48)) {
    lcd.setCursor(0, 0);
    lcd.print("Erro ADS1115!");
    while(1) { 
      wdt_reset();
      delay(1000); 
    }
  }
  ads1115.setGain(GAIN_TWOTHIRDS);
  
  // Inicializar buffer de leituras
  for (int i = 0; i < READINGS_BUFFER_SIZE; i++) {
    phReadings[i] = 7.0;
  }
  
  // Carregar configurações
  EEPROM.get(EEPROM_PH_IDEAL, targetPh);
  if (isnan(targetPh) || targetPh < PH_MIN || targetPh > PH_MAX) {
    targetPh = PH_DEFAULT;
    EEPROM.put(EEPROM_PH_IDEAL, targetPh);
  }
  
  EEPROM.get(EEPROM_CALIB_OFFSET, calibOffset);
  EEPROM.get(EEPROM_CALIB_SLOPE, calibSlope);
  
  if (isnan(calibOffset) || isnan(calibSlope) || calibSlope == 0.0) {
    calibOffset = 2.5;
    calibSlope = 0.18;
    EEPROM.put(EEPROM_CALIB_OFFSET, calibOffset);
    EEPROM.put(EEPROM_CALIB_SLOPE, calibSlope);
  }
  
  currentState = BOOT;
  stateEntryTime = millis();
  lastButtonPress = millis();
}

// =========== LOOP PRINCIPAL ===========
void loop() {
  wdt_reset();
  
  handleButtons();
  handleStateMachine();
  updateSensors();
  
  // Atualizar display com intervalo controlado
  if (millis() - lastDisplayUpdate >= DISPLAY_UPDATE_INTERVAL) {
    lastDisplayUpdate = millis();
    updateDisplay();
  }
  
  // Controle automático da bomba
  if (isPumpRunning && (millis() - lastPumpActivation > PUMP_RUN_TIME)) {
    stopPump();
    needsRedraw = true;
  }
}

// =========== MÁQUINA DE ESTADOS ===========
void handleStateMachine() {
  unsigned long currentTime = millis();
  
  // Timeout do menu (30 segundos)
  if (currentState != BOOT && currentState != MONITORING && 
      currentTime - lastButtonPress > MENU_TIMEOUT) {
    currentState = MONITORING;
    needsRedraw = true;
    return;
  }
  
  switch (currentState) {
    case BOOT:
      if (currentTime - stateEntryTime > SENSOR_STABILIZE_TIME) {
        currentState = MONITORING;
        needsRedraw = true;
      }
      break;
      
    default:
      break;
  }
}

// =========== ATUALIZAÇÃO DE SENSORES ===========
void updateSensors() {
  unsigned long currentTime = millis();
  
  if (currentTime - lastReadingTime >= READING_INTERVAL) {
    lastReadingTime = currentTime;
    
    // Ler temperatura
    tempSensor.requestTemperatures();
    currentTemp = tempSensor.getTempCByIndex(0);
    if (currentTemp == DEVICE_DISCONNECTED_C) {
      currentTemp = 25.0;
    }
    
    // Ler PH instantâneo - SIMULAÇÃO
    float voltage = 2.5 + (sin(millis() / 10000.0) * 0.5);
    instantPh = calculatePh(voltage, currentTemp);
    
    // Atualizar buffer para média
    phReadings[currentReadingIndex] = instantPh;
    currentReadingIndex = (currentReadingIndex + 1) % READINGS_BUFFER_SIZE;
  }
  
  if (currentTime - lastAveragingTime >= AVERAGING_INTERVAL) {
    lastAveragingTime = currentTime;
    calculatePhAverage();
    checkPhAdjustment();
  }
}

float readPhVoltage() {
  int16_t adcValue = ads1115.readADC_SingleEnded(0);
  return adcValue * ADS1115_CONVERSION_FACTOR;
}

void calculatePhAverage() {
  float sortedReadings[READINGS_BUFFER_SIZE];
  memcpy(sortedReadings, phReadings, sizeof(phReadings));
  
  // Ordenar leituras
  for (int i = 0; i < READINGS_BUFFER_SIZE - 1; i++) {
    for (int j = i + 1; j < READINGS_BUFFER_SIZE; j++) {
      if (sortedReadings[i] > sortedReadings[j]) {
        float temp = sortedReadings[i];
        sortedReadings[i] = sortedReadings[j];
        sortedReadings[j] = temp;
      }
    }
  }
  
  // Calcular média sem outliers
  float sum = 0;
  for (int i = 2; i < READINGS_BUFFER_SIZE - 2; i++) {
    sum += sortedReadings[i];
  }
  currentPh = sum / (READINGS_BUFFER_SIZE - 4);
}

void checkPhAdjustment() {
  if (currentPh > targetPh + PH_VARIATION_THRESHOLD) {
    phAdjustmentNeeded = true;
    setStatusLed(false);
  } else if (currentPh < targetPh - PH_VARIATION_THRESHOLD) {
    phAdjustmentNeeded = false;
    setStatusLed(true);
  } else {
    setStatusLed(false);
    phAdjustmentNeeded = false;
  }
  
  unsigned long currentTime = millis();
  if (phAdjustmentNeeded && !isPumpRunning && 
      currentTime - lastPumpActivation > PUMP_COOLDOWN) {
    startPump();
    needsRedraw = true;
  }
}

float calculatePh(float voltage, float temperature) {
  float phValue = (voltage - calibOffset) / calibSlope;
  float tempCompensation = 1.0 + 0.03 * (temperature - 25.0);
  return phValue / tempCompensation;
}

// =========== CONTROLE DE BOTÕES ===========
void handleButtons() {
  static unsigned long lastDebounceTime = 0;
  static uint8_t lastButtonState = 0;
  const unsigned long debounceDelay = 50;
  
  uint8_t currentButtonState = 0;
  if (digitalRead(PIN_BUTTON_MENU) == LOW) currentButtonState |= 1;
  if (digitalRead(PIN_BUTTON_DOWN) == LOW) currentButtonState |= 2;
  if (digitalRead(PIN_BUTTON_UP) == LOW) currentButtonState |= 4;
  
  if (currentButtonState != lastButtonState) {
    lastDebounceTime = millis();
  }
  
  if ((millis() - lastDebounceTime) > debounceDelay) {
    if (currentButtonState != 0 && currentButtonState != lastButtonState) {
      lastButtonPress = millis();
      
      if (currentButtonState & 1) {
        processButtonPress(0); // MENU
      } else if (currentButtonState & 2) {
        processButtonPress(1); // DOWN
      } else if (currentButtonState & 4) {
        processButtonPress(2); // UP
      }
      
      needsRedraw = true;
    }
  }
  
  lastButtonState = currentButtonState;
}

void processButtonPress(int button) {
  Serial.print("Botão pressionado: ");
  Serial.print(button);
  Serial.print(" Estado: ");
  Serial.println(currentState);
  
  switch (currentState) {
    case MONITORING:
      if (button == 0) {
        currentState = MAIN_MENU;
        menuPosition = 0;
      }
      break;
      
    case MAIN_MENU:
      handleMainMenuButtons(button);
      break;
      
    case SET_PH_MENU:
      handleSetPhMenuButtons(button);
      break;
      
    case CALIBRATE_MENU:
      handleCalibrateMenuButtons(button);
      break;
      
    case CALIBRATE_1POINT_MENU:
      if (button == 0) {
        currentState = CALIBRATE_1POINT_SOLUTION;
        subMenuPosition = 0;
      } else {
        currentState = CALIBRATE_MENU;
      }
      break;
      
    case CALIBRATE_1POINT_SOLUTION:
      handleCalibrate1PointSolutionButtons(button);
      break;
      
    case TECH_MENU:
      handleTechMenuButtons(button);
      break;
      
    case RAW_VALUES:
      if (button == 0) currentState = TECH_MENU;
      break;
      
    case SENSOR_CHECK:
      if (button == 0) currentState = TECH_MENU;
      break;
      
    case RESTART_CONFIRM:
      handleRestartConfirmButtons(button);
      break;
      
    default:
      break;
  }
}

// =========== HANDLERS DE MENU ===========
void handleMainMenuButtons(int button) {
  switch (button) {
    case 0: // MENU
      if (menuPosition == 0) {
        currentState = SET_PH_MENU;
      } else if (menuPosition == 1) {
        currentState = CALIBRATE_MENU;
      } else if (menuPosition == 2) {
        currentState = TECH_MENU;
      } else if (menuPosition == 3) {
        currentState = MONITORING;
      }
      break;
    case 1: // DOWN
      menuPosition = (menuPosition + 1) % 4;
      break;
    case 2: // UP
      menuPosition = (menuPosition == 0) ? 3 : menuPosition - 1;
      break;
  }
}

void handleSetPhMenuButtons(int button) {
  switch (button) {
    case 0: // MENU - Salvar
      EEPROM.put(EEPROM_PH_IDEAL, targetPh);
      currentState = MAIN_MENU;
      menuPosition = 0;
      break;
    case 1: // DOWN - Diminuir PH
      targetPh = max(PH_MIN, targetPh - 0.1);
      break;
    case 2: // UP - Aumentar PH
      targetPh = min(PH_MAX, targetPh + 0.1);
      break;
  }
}

void handleCalibrateMenuButtons(int button) {
  switch (button) {
    case 0: // MENU
      if (menuPosition == 0) {
        currentState = CALIBRATE_1POINT_MENU;
      } else if (menuPosition == 1) {
        // CALIBRATE_2POINT_MENU removido para simplificação
        currentState = MAIN_MENU;
      } else if (menuPosition == 2) {
        currentState = MAIN_MENU;
      }
      break;
    case 1: // DOWN
      menuPosition = (menuPosition + 1) % 3;
      break;
    case 2: // UP
      menuPosition = (menuPosition == 0) ? 2 : menuPosition - 1;
      break;
  }
}

void handleCalibrate1PointSolutionButtons(int button) {
  switch (button) {
    case 0: // MENU
      if (subMenuPosition < 3) {
        currentState = CALIBRATE_1POINT_MEASURING;
        stateEntryTime = millis();
      } else {
        currentState = CALIBRATE_1POINT_MENU;
      }
      break;
    case 1: // DOWN
      subMenuPosition = (subMenuPosition + 1) % 4;
      break;
    case 2: // UP
      subMenuPosition = (subMenuPosition == 0) ? 3 : subMenuPosition - 1;
      break;
  }
}

void handleTechMenuButtons(int button) {
  switch (button) {
    case 0: // MENU
      if (menuPosition == 0) {
        currentState = RAW_VALUES;
      } else if (menuPosition == 1) {
        currentState = SENSOR_CHECK;
        stateEntryTime = millis();
      } else if (menuPosition == 2) {
        currentState = RESTART_CONFIRM;
        menuPosition = 0;
      } else if (menuPosition == 3) {
        currentState = MAIN_MENU;
      }
      break;
    case 1: // DOWN
      menuPosition = (menuPosition + 1) % 4;
      break;
    case 2: // UP
      menuPosition = (menuPosition == 0) ? 3 : menuPosition - 1;
      break;
  }
}

void handleRestartConfirmButtons(int button) {
  switch (button) {
    case 0: // MENU
      if (menuPosition == 0) {
        safeReset();
      } else {
        currentState = TECH_MENU;
      }
      break;
    case 1: // DOWN
      menuPosition = (menuPosition + 1) % 2;
      break;
    case 2: // UP
      menuPosition = (menuPosition == 0) ? 1 : menuPosition - 1;
      break;
  }
}

// =========== ATUALIZAÇÃO DO DISPLAY ===========
void updateDisplay() {
  if (!needsRedraw) return;
  
  lcd.clear();
  
  switch (currentState) {
    case BOOT:
      drawBootScreen();
      break;
    case MONITORING:
      drawMonitoringScreen();
      break;
    case MAIN_MENU:
      drawMainMenu();
      break;
    case SET_PH_MENU:
      drawSetPhMenu();
      break;
    case CALIBRATE_MENU:
      drawCalibrateMenu();
      break;
    case CALIBRATE_1POINT_MENU:
      drawCalibrate1PointMenu();
      break;
    case CALIBRATE_1POINT_SOLUTION:
      drawCalibrate1PointSolution();
      break;
    case CALIBRATE_1POINT_MEASURING:
      drawCalibrate1PointMeasuring();
      break;
    case TECH_MENU:
      drawTechMenu();
      break;
    case RAW_VALUES:
      drawRawValues();
      break;
    case SENSOR_CHECK:
      drawSensorCheck();
      break;
    case RESTART_CONFIRM:
      drawRestartConfirm();
      break;
  }
  
  needsRedraw = false;
}

void drawBootScreen() {
  lcd.setCursor(0, 0);
  lcd.print("Sistema Iniciando");
  lcd.setCursor(0, 1);
  lcd.print("Aguarde ");
  
  unsigned long timeLeft = (SENSOR_STABILIZE_TIME - (millis() - stateEntryTime)) / 1000;
  lcd.print(timeLeft);
  lcd.print("s");
  
  lcd.setCursor(0, 2);
  lcd.print("Inicializando");
  lcd.setCursor(0, 3);
  lcd.print("sensores...");
}

void drawMonitoringScreen() {
  lcd.setCursor(0, 0);
  
  // Indicador de atividade
  static uint8_t animFrame = 0;
  static unsigned long lastAnimUpdate = 0;
  if (millis() - lastAnimUpdate > 500) {
    animFrame = (animFrame + 1) % 4;
    lastAnimUpdate = millis();
  }
  char animChars[] = {'|', '/', '-', '\\'};
  
  if (isPumpRunning) {
    lcd.print("AJUSTANDO PH     ");
    int progress = min(18, (int)((millis() - lastPumpActivation) * 18) / PUMP_RUN_TIME);
    lcd.setCursor(0, 3);
    lcd.print("[");
    for (int i = 0; i < 18; i++) {
      lcd.print(i < progress ? "=" : " ");
    }
    lcd.print("]");
  } else if (isLedOn) {
    lcd.print("PH ABAIXO DO IDEAL");
  } else {
    lcd.print("MONITORANDO ");
    lcd.print(animChars[animFrame]);
  }
  
  if (!isPumpRunning) {
    lcd.setCursor(0, 1);
    lcd.print("PH ATUAL: ");
    lcd.print(currentPh, 2);
    
    lcd.setCursor(0, 2);
    lcd.print("PH INST:  ");
    lcd.print(instantPh, 2);
    
    lcd.setCursor(0, 3);
    lcd.print("Temp:");
    lcd.print(currentTemp, 1);
    lcd.print("C Ideal:");
    lcd.print(targetPh, 1);
  }
}

void drawMainMenu() {
  lcd.setCursor(0, 0);
  lcd.print("MENU PRINCIPAL");
  
  lcd.setCursor(0, 1);
  if (menuPosition == 0) {
    lcd.print(">Definir PH Ideal");
  } else {
    lcd.print(" Definir PH Ideal");
  }
  
  lcd.setCursor(0, 2);
  if (menuPosition == 1) {
    lcd.print(">Calibrar Sonda  ");
  } else {
    lcd.print(" Calibrar Sonda  ");
  }
  
  lcd.setCursor(0, 3);
  if (menuPosition == 2) {
    lcd.print(">Menu Tecnico    ");
  } else if (menuPosition == 3) {
    lcd.print(">Voltar          ");
  } else {
    lcd.print(" Menu Tecnico    ");
  }
}

void drawSetPhMenu() {
  lcd.setCursor(0, 0);
  lcd.print("DEFINIR PH IDEAL");
  lcd.setCursor(0, 1);
  lcd.print("PH Ideal: ");
  lcd.print(targetPh, 1);
  lcd.setCursor(0, 3);
  lcd.print("Press MENU p/ salvar");
}

void drawCalibrateMenu() {
  lcd.setCursor(0, 0);
  lcd.print("CALIBRAR SONDA");
  lcd.setCursor(0, 1);
  if (menuPosition == 0) {
    lcd.print(">1 PONTO ");
  } else {
    lcd.print(" 1 PONTO ");
  }
  
  lcd.setCursor(0, 2);
  if (menuPosition == 1) {
    lcd.print(">VOLTAR  ");
  } else {
    lcd.print(" VOLTAR  ");
  }
}

void drawCalibrate1PointMenu() {
  lcd.setCursor(0, 0);
  lcd.print("CALIBRAR 1 PONTO");
  lcd.setCursor(0, 1);
  lcd.print("Insira a sonda na");
  lcd.setCursor(0, 2);
  lcd.print("solucao e pressione");
  lcd.setCursor(0, 3);
  lcd.print("MENU p/ continuar");
}

void drawCalibrate1PointSolution() {
  lcd.setCursor(0, 0);
  lcd.print("SELECIONE SOLUCAO:");
  lcd.setCursor(0, 1);
  if (subMenuPosition == 0) {
    lcd.print(">4.01");
  } else {
    lcd.print(" 4.01");
  }
  
  lcd.setCursor(0, 2);
  if (subMenuPosition == 1) {
    lcd.print(">7.01");
  } else {
    lcd.print(" 7.01");
  }
  
  lcd.setCursor(0, 3);
  if (subMenuPosition == 2) {
    lcd.print(">10.1          ");
  } else if (subMenuPosition == 3) {
    lcd.print("          >Voltar");
  } else {
    lcd.print(" 10.1           ");
  }
}

void drawCalibrate1PointMeasuring() {
  lcd.setCursor(0, 0);
  lcd.print("CALIBRANDO...");
  lcd.setCursor(0, 1);
  lcd.print("Aguarde 15 segundos");
  lcd.setCursor(0, 3);
  
  unsigned long elapsed = millis() - stateEntryTime;
  if (elapsed < 15000) {
    lcd.print("Tempo: ");
    lcd.print((15000 - elapsed) / 1000);
    lcd.print("s   ");
  } else {
    lcd.print("Calibracao OK!    ");
    delay(2000);
    currentState = MONITORING;
    needsRedraw = true;
  }
}

void drawTechMenu() {
  lcd.setCursor(0, 0);
  lcd.print("MENU TECNICO");
  lcd.setCursor(0, 1);
  if (menuPosition == 0) {
    lcd.print(">Valores Brutos  ");
  } else {
    lcd.print(" Valores Brutos  ");
  }
  
  lcd.setCursor(0, 2);
  if (menuPosition == 1) {
    lcd.print(">Checar Sensores ");
  } else {
    lcd.print(" Checar Sensores ");
  }
  
  lcd.setCursor(0, 3);
  if (menuPosition == 2) {
    lcd.print(">Reiniciar       ");
  } else if (menuPosition == 3) {
    lcd.print(">Voltar          ");
  } else {
    lcd.print(" Reiniciar       ");
  }
}

void drawRawValues() {
  lcd.setCursor(0, 0);
  lcd.print("VALORES BRUTOS");
  lcd.setCursor(0, 1);
  lcd.print("Tensao PH: ");
  lcd.print(readPhVoltage(), 4);
  lcd.print("V");
  lcd.setCursor(0, 3);
  lcd.print("Press MENU p/ voltar");
}

void drawSensorCheck() {
  lcd.setCursor(0, 0);
  lcd.print("TESTANDO SENSORES");
  
  static uint8_t progress = 0;
  unsigned long elapsed = millis() - stateEntryTime;
  progress = min(18, (int)(elapsed * 18) / 6000);
  
  lcd.setCursor(0, 2);
  lcd.print("[");
  for (int i = 0; i < 18; i++) {
    lcd.print(i < progress ? "=" : " ");
  }
  lcd.print("]");
  
  if (progress == 18) {
    lcd.setCursor(0, 3);
    lcd.print("Teste completo! OK");
  } else {
    lcd.setCursor(0, 3);
    lcd.print("Aguarde...");
  }
}

void drawRestartConfirm() {
  lcd.setCursor(0, 0);
  lcd.print("REINICIAR SISTEMA?");
  lcd.setCursor(0, 2);
  if (menuPosition == 0) {
    lcd.print(">SIM");
  } else {
    lcd.print(" SIM");
  }
  
  lcd.setCursor(10, 2);
  if (menuPosition == 1) {
    lcd.print(">NAO");
  } else {
    lcd.print(" NAO");
  }
}

// =========== CONTROLE DE HARDWARE ===========
void startPump() {
  digitalWrite(PIN_MOSFET_TRIG, HIGH);
  isPumpRunning = true;
  lastPumpActivation = millis();
}

void stopPump() {
  digitalWrite(PIN_MOSFET_TRIG, LOW);
  isPumpRunning = false;
}

void setStatusLed(bool state) {
  digitalWrite(PIN_STATUS_LED, state ? HIGH : LOW);
  isLedOn = state;
}

void safeReset() {
  stopPump();
  setStatusLed(false);
  wdt_disable();
  asm("jmp 0");
}
