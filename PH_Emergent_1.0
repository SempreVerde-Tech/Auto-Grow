/*
 * CONTROLADOR AUTOMÁTICO DE PH PARA CULTIVO HIDROPÔNICO
 * Desenvolvido para Arduino NANO
 * 
 * Este sistema monitora e controla automaticamente o pH de soluções nutritivas
 * para cultivo hidropônico, com interface LCD e controle via botões touch.
 * 
 * COMPONENTES:
 * - Arduino NANO
 * - Display LCD I2C 20x4
 * - Sensor de pH analógico com sonda
 * - Sensor de temperatura DS18B20
 * - ADS1115 (Conversor A/D 16-bit)
 * - Módulo MOSFET 15A
 * - Bomba peristáltica 5V
 * - 3 botões touch
 * - LED indicador
 * 
 * Autor: Sistema Emergent
 * Data: Agosto 2025
 */

#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ADS1X15.h>
#include <EEPROM.h>
#include <avr/wdt.h>

// ==================== DEFINIÇÕES DE PINOS ====================
#define PIN_DS18B20         2    // Sensor de temperatura
#define PIN_BTN_MENU        3    // Botão MENU (touch)
#define PIN_BTN_DOWN        4    // Botão DOWN (touch)
#define PIN_BTN_UP          5    // Botão UP (touch)
#define PIN_MOSFET          6    // Controle da bomba via MOSFET
#define PIN_LED             7    // LED indicador
// Pinos I2C: A4 (SDA), A5 (SCL) - LCD e ADS1115

// ==================== CONSTANTES DO SISTEMA ====================
// Endereços EEPROM para armazenar configurações
#define EEPROM_PH_IDEAL     0    // float (4 bytes)
#define EEPROM_CAL_OFFSET   4    // float (4 bytes) 
#define EEPROM_CAL_SLOPE    8    // float (4 bytes)
#define EEPROM_INITIALIZED  12   // byte (1 byte) - marca se EEPROM foi inicializada

// Valores padrão
#define PH_IDEAL_DEFAULT    7.0f
#define PH_MIN              1.0f
#define PH_MAX              13.0f
#define PH_STEP             0.1f
#define PH_TOLERANCE        0.3f  // Tolerância para detecção de variação
#define PH_STABILITY        0.1f  // Tolerância para estabilidade

// Tempos (em milissegundos)
#define TEMPO_INATIVIDADE   30000UL  // 30 segundos para retornar à tela inicial
#define TEMPO_BOMBA         1000UL   // 1 segundo acionamento da bomba
#define TEMPO_ESPERA_BOMBA  300000UL // 5 minutos entre acionamentos da bomba
#define INTERVALO_LEITURA   1000UL   // 1 segundo entre leituras
#define INTERVALO_MEDIA     15000UL  // 15 segundos para atualizar média

// Calibração
#define AMOSTRAS_CALIBRACAO 15       // Número de amostras para calibração
#define MAX_TENTATIVAS_CAL  5        // Máximo de tentativas de calibração
#define DESCARTAR_EXTREMOS  2        // Quantas amostras extremas descartar

// Estados do sistema
enum EstadoSistema {
  INICIALIZANDO,
  MENU_INICIAL,
  MONITORANDO,
  MENU_PRINCIPAL,
  DEFINIR_PH_IDEAL,
  CALIBRAR_SONDA,
  CAL_1_PONTO,
  CAL_2_PONTOS,
  CAL_SELECAO_SOL1,
  CAL_SELECAO_SOL2,
  CAL_MEDINDO,
  MENU_TECNICO,
  VALORES_BRUTOS,
  CHECAR_SENSORES,
  REINICIAR_SISTEMA
};

// ==================== OBJETOS GLOBAIS ====================
LiquidCrystal_I2C lcd(0x27, 20, 4);  // Display LCD I2C
OneWire oneWire(PIN_DS18B20);         // Comunicação OneWire
DallasTemperature sensorTemp(&oneWire); // Sensor de temperatura
ADS1115 ads(0x48);                    // Conversor A/D

// ==================== VARIÁVEIS GLOBAIS ====================
// Estado do sistema
EstadoSistema estadoAtual = INICIALIZANDO;
EstadoSistema estadoAnterior = INICIALIZANDO;

// Variáveis de tempo
unsigned long tempoAtual = 0;
unsigned long tempoUltimaAtividade = 0;
unsigned long tempoUltimaLeitura = 0;
unsigned long tempoUltimaMedia = 0;
unsigned long tempoUltimaBomba = 0;

// Variáveis de pH e temperatura
float phAtual = 7.0f;
float phInstantaneo = 7.0f;
float phIdeal = PH_IDEAL_DEFAULT;
float temperatura = 25.0f;
float tensaoBrutaPh = 0.0f;

// Arrays para médias
float leiturasPh[AMOSTRAS_CALIBRACAO];
int indiceLeitura = 0;
bool arrayPreenchido = false;

// Calibração
float offsetCalibracao = 0.0f;
float slopeCalibracao = 1.0f;
bool sondaCalibrada = false;

// Controle de botões
bool btnMenuPressed = false;
bool btnUpPressed = false;
bool btnDownPressed = false;
unsigned long tempoDebounce = 0;
#define DEBOUNCE_DELAY 50

// Controle do sistema
bool sistemaEstavel = false;
int contadorEstabilidade = 0;
bool bombaAtiva = false;
bool alertaPh = false;

// Menus
int opcaoMenuPrincipal = 0;
int opcaoMenuInicial = 0;
int opcaoMenuTecnico = 0;
int opcaoSolucaoCalPH = 0;
float valoresSolucoes[] = {4.01f, 7.01f, 10.1f};
int numSolucoes = 3;

// Barra de progresso
int posicaoBarraProgress = 0;
unsigned long tempoUltimaBarraUpdate = 0;

// ==================== CONFIGURAÇÃO INICIAL ====================
void setup() {
  // Inicializar watchdog timer (8 segundos)
  wdt_enable(WDTO_8S);
  
  // Inicializar Serial para debug (opcional)
  Serial.begin(9600);
  
  // Configurar pinos
  pinMode(PIN_BTN_MENU, INPUT_PULLUP);
  pinMode(PIN_BTN_DOWN, INPUT_PULLUP);
  pinMode(PIN_BTN_UP, INPUT_PULLUP);
  pinMode(PIN_MOSFET, OUTPUT);
  pinMode(PIN_LED, OUTPUT);
  
  digitalWrite(PIN_MOSFET, LOW);  // Bomba desligada
  digitalWrite(PIN_LED, LOW);     // LED desligado
  
  // Inicializar I2C
  Wire.begin();
  
  // Inicializar LCD
  lcd.init();
  lcd.backlight();
  lcd.clear();
  
  // Mensagem de inicialização
  lcd.setCursor(0, 0);
  lcd.print("CONTROLADOR PH v1.0");
  lcd.setCursor(0, 1);
  lcd.print("Inicializando...");
  
  // Inicializar ADS1115
  if (!ads.begin()) {
    lcd.setCursor(0, 2);
    lcd.print("ERRO: ADS1115");
    while (1) {
      wdt_reset(); // Prevenir reset do watchdog
      delay(100);
    }
  }
  ads.setGain(0);  // +/- 6.144V range
  
  // Inicializar sensor de temperatura
  sensorTemp.begin();
  if (sensorTemp.getDeviceCount() == 0) {
    lcd.setCursor(0, 2);
    lcd.print("ERRO: Sensor Temp");
    while (1) {
      wdt_reset();
      delay(100);
    }
  }
  
  // Carregar configurações da EEPROM
  carregarConfiguracoes();
  
  // Aguardar estabilização dos sensores
  lcd.setCursor(0, 2);
  lcd.print("Estabilizando...");
  for (int i = 0; i < 30; i++) {
    wdt_reset();
    delay(100);
  }
  
  // Ir para menu inicial
  estadoAtual = MENU_INICIAL;
  mostrarMenuInicial();
  tempoUltimaAtividade = millis();
  
  Serial.println("Sistema inicializado com sucesso");
}

// ==================== LOOP PRINCIPAL ====================
void loop() {
  wdt_reset(); // Alimentar watchdog
  
  tempoAtual = millis();
  
  // Ler botões
  lerBotoes();
  
  // Máquina de estados
  switch (estadoAtual) {
    case MENU_INICIAL:
      processarMenuInicial();
      break;
      
    case MONITORANDO:
      processarMonitoramento();
      break;
      
    case MENU_PRINCIPAL:
      processarMenuPrincipal();
      break;
      
    case DEFINIR_PH_IDEAL:
      processarDefinirPhIdeal();
      break;
      
    case CALIBRAR_SONDA:
      processarMenuCalibracao();
      break;
      
    case CAL_SELECAO_SOL1:
      processarSelecaoSolucao1();
      break;
      
    case CAL_SELECAO_SOL2:
      processarSelecaoSolucao2();
      break;
      
    case CAL_MEDINDO:
      processarCalibracao();
      break;
      
    case MENU_TECNICO:
      processarMenuTecnico();
      break;
      
    case VALORES_BRUTOS:
      processarValoresBrutos();
      break;
      
    case CHECAR_SENSORES:
      processarChecarSensores();
      break;
      
    case REINICIAR_SISTEMA:
      processarReiniciarSistema();
      break;
  }
  
  // Verificar timeout de inatividade
  verificarTimeoutInatividade();
  
  // Atualizar barra de progresso se necessário
  atualizarBarraProgress();
}

// ==================== FUNÇÕES DE LEITURA DE SENSORES ====================

/**
 * Lê a temperatura do sensor DS18B20
 * @return temperatura em graus Celsius
 */
float lerTemperatura() {
  sensorTemp.requestTemperatures();
  float temp = sensorTemp.getTempCByIndex(0);
  
  // Verificar se a leitura é válida
  if (temp == DEVICE_DISCONNECTED_C || temp < -55 || temp > 125) {
    return 25.0f; // Valor padrão em caso de erro
  }
  
  return temp;
}

/**
 * Lê a tensão bruta do sensor de pH através do ADS1115
 * @return tensão em volts
 */
float lerTensaoBrutaPH() {
  int16_t valorADC = ads.readADC(0);  // Canal A0
  float tensao = ads.computeVolts(valorADC);
  
  // Limitar tensão dentro do range esperado
  if (tensao < 0) tensao = 0;
  if (tensao > 5.0) tensao = 5.0;
  
  return tensao;
}

/**
 * Converte tensão bruta em valor de pH, compensado por temperatura
 * @param tensao tensão lida do sensor
 * @param temp temperatura atual
 * @return valor de pH
 */
float converterTensaoParaPH(float tensao, float temp) {
  // Compensação de temperatura (coeficiente típico: -0.0198 pH/°C)
  float compensacaoTemp = (temp - 25.0f) * (-0.0198f);
  
  // Conversão básica: assumindo sensor com saída linear
  // pH 7 = ~2.5V, inclinação típica: ~0.18V/pH
  float phBase = 7.0f - ((tensao - 2.5f) / 0.18f);
  
  // Aplicar calibração se disponível
  float phFinal = (phBase + offsetCalibracao) * slopeCalibracao;
  
  // Aplicar compensação de temperatura
  phFinal += compensacaoTemp;
  
  // Limitar pH dentro do range válido
  if (phFinal < PH_MIN) phFinal = PH_MIN;
  if (phFinal > PH_MAX) phFinal = PH_MAX;
  
  return phFinal;
}

/**
 * Realiza múltiplas leituras de pH e calcula a média descartando extremos
 * @return valor médio de pH
 */
float lerPhComMedia() {
  float leituras[AMOSTRAS_CALIBRACAO];
  
  // Coletar amostras
  for (int i = 0; i < AMOSTRAS_CALIBRACAO; i++) {
    temperatura = lerTemperatura();
    tensaoBrutaPh = lerTensaoBrutaPH();
    leituras[i] = converterTensaoParaPH(tensaoBrutaPh, temperatura);
    
    if (i < AMOSTRAS_CALIBRACAO - 1) {
      delay(1000); // Aguardar 1 segundo entre leituras
      wdt_reset();
    }
  }
  
  // Ordenar array para descartar extremos
  for (int i = 0; i < AMOSTRAS_CALIBRACAO - 1; i++) {
    for (int j = i + 1; j < AMOSTRAS_CALIBRACAO; j++) {
      if (leituras[i] > leituras[j]) {
        float temp = leituras[i];
        leituras[i] = leituras[j];
        leituras[j] = temp;
      }
    }
  }
  
  // Calcular média descartando extremos
  float soma = 0;
  int contagem = 0;
  for (int i = DESCARTAR_EXTREMOS; i < AMOSTRAS_CALIBRACAO - DESCARTAR_EXTREMOS; i++) {
    soma += leituras[i];
    contagem++;
  }
  
  return (contagem > 0) ? soma / contagem : 7.0f;
}

// ==================== FUNÇÕES DE INTERFACE ====================

/**
 * Lê o estado dos botões com debounce
 */
void lerBotoes() {
  static bool ultimoEstadoMenu = HIGH;
  static bool ultimoEstadoUp = HIGH;
  static bool ultimoEstadoDown = HIGH;
  
  bool estadoAtualMenu = digitalRead(PIN_BTN_MENU);
  bool estadoAtualUp = digitalRead(PIN_BTN_UP);
  bool estadoAtualDown = digitalRead(PIN_BTN_DOWN);
  
  // Debounce
  if (tempoAtual - tempoDebounce > DEBOUNCE_DELAY) {
    // Botão MENU
    if (ultimoEstadoMenu == HIGH && estadoAtualMenu == LOW) {
      btnMenuPressed = true;
      tempoUltimaAtividade = tempoAtual;
      tempoDebounce = tempoAtual;
    }
    
    // Botão UP
    if (ultimoEstadoUp == HIGH && estadoAtualUp == LOW) {
      btnUpPressed = true;
      tempoUltimaAtividade = tempoAtual;
      tempoDebounce = tempoAtual;
    }
    
    // Botão DOWN
    if (ultimoEstadoDown == HIGH && estadoAtualDown == LOW) {
      btnDownPressed = true;
      tempoUltimaAtividade = tempoAtual;
      tempoDebounce = tempoAtual;
    }
    
    ultimoEstadoMenu = estadoAtualMenu;
    ultimoEstadoUp = estadoAtualUp;
    ultimoEstadoDown = estadoAtualDown;
  }
}

/**
 * Limpa todas as flags de botões pressionados
 */
void limparBotoes() {
  btnMenuPressed = false;
  btnUpPressed = false;
  btnDownPressed = false;
}

/**
 * Mostra o menu inicial com 3 opções
 */
void mostrarMenuInicial() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("   MENU INICIAL");
  
  // Opções do menu
  const char* opcoes[] = {"Monitorar", "Calibrar Sonda", "Menu Tecnico"};
  
  for (int i = 0; i < 3; i++) {
    lcd.setCursor(0, i + 1);
    if (i == opcaoMenuInicial) {
      lcd.print("> ");
    } else {
      lcd.print("  ");
    }
    lcd.print(opcoes[i]);
  }
}

/**
 * Mostra a tela de monitoramento com informações do sistema
 */
void mostrarTelaMonitoramento() {
  lcd.clear();
  
  // Linha 1: MONITORANDO com barra giratória
  lcd.setCursor(0, 0);
  lcd.print("MONITORANDO ");
  static char barrinha[] = {'-', '\\', '|', '/'};
  static int posBarrinha = 0;
  lcd.print(barrinha[posBarrinha]);
  posBarrinha = (posBarrinha + 1) % 4;
  
  // Verificar se há alerta de pH
  if (alertaPh) {
    lcd.setCursor(14, 0);
    lcd.print("PH<IDA");
  }
  
  // Linha 2: pH ATUAL
  lcd.setCursor(0, 1);
  lcd.print("PH ATUAL: ");
  lcd.print(phAtual, 1);
  
  // Linha 3: pH INST
  lcd.setCursor(0, 2);
  lcd.print("PH INST: ");
  lcd.print(phInstantaneo, 1);
  
  // Linha 4: Temperatura e pH Ideal
  lcd.setCursor(0, 3);
  lcd.print("Temp:");
  lcd.print(temperatura, 1);
  lcd.print("C|Ideal:");
  lcd.print(phIdeal, 1);
}

/**
 * Mostra o menu principal
 */
void mostrarMenuPrincipal() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("  MENU PRINCIPAL");
  
  const char* opcoes[] = {"Definir PH Ideal", "Calibrar Sonda", "Menu Tecnico", "Voltar"};
  
  for (int i = 0; i < 4; i++) {
    lcd.setCursor(0, i + 1);
    if (i == opcaoMenuPrincipal) {
      lcd.print(">");
    } else {
      lcd.print(" ");
    }
    
    if (i < 3) {
      lcd.print(opcoes[i]);
    } else {
      lcd.setCursor(1, 3);
      lcd.print("Voltar");
    }
  }
}

/**
 * Atualiza a barra de progresso giratória
 */
void atualizarBarraProgress() {
  if (tempoAtual - tempoUltimaBarraUpdate > 200) {
    posicaoBarraProgress = (posicaoBarraProgress + 1) % 10;
    tempoUltimaBarraUpdate = tempoAtual;
  }
}

// ==================== PROCESSAMENTO DE ESTADOS ====================

/**
 * Processa o menu inicial
 */
void processarMenuInicial() {
  if (btnUpPressed) {
    opcaoMenuInicial = (opcaoMenuInicial - 1 + 3) % 3;
    mostrarMenuInicial();
    limparBotoes();
  }
  
  if (btnDownPressed) {
    opcaoMenuInicial = (opcaoMenuInicial + 1) % 3;
    mostrarMenuInicial();
    limparBotoes();
  }
  
  if (btnMenuPressed) {
    switch (opcaoMenuInicial) {
      case 0: // Monitorar
        estadoAtual = MONITORANDO;
        mostrarTelaMonitoramento();
        break;
      case 1: // Calibrar Sonda
        estadoAtual = CALIBRAR_SONDA;
        mostrarMenuCalibracao();
        break;
      case 2: // Menu Técnico
        estadoAtual = MENU_TECNICO;
        opcaoMenuTecnico = 0;
        mostrarMenuTecnico();
        break;
    }
    limparBotoes();
  }
}

/**
 * Processa o monitoramento contínuo
 */
void processarMonitoramento() {
  // Atualizar leituras instantâneas a cada segundo
  if (tempoAtual - tempoUltimaLeitura >= INTERVALO_LEITURA) {
    temperatura = lerTemperatura();
    tensaoBrutaPh = lerTensaoBrutaPH();
    phInstantaneo = converterTensaoParaPH(tensaoBrutaPh, temperatura);
    
    // Adicionar leitura ao array circular
    leiturasPh[indiceLeitura] = phInstantaneo;
    indiceLeitura = (indiceLeitura + 1) % AMOSTRAS_CALIBRACAO;
    if (indiceLeitura == 0) arrayPreenchido = true;
    
    tempoUltimaLeitura = tempoAtual;
    mostrarTelaMonitoramento();
  }
  
  // Atualizar média a cada 15 segundos
  if (tempoAtual - tempoUltimaMedia >= INTERVALO_MEDIA && arrayPreenchido) {
    calcularMediaPh();
    verificarControlePh();
    tempoUltimaMedia = tempoAtual;
  }
  
  // Abrir menu principal se MENU pressionado
  if (btnMenuPressed) {
    estadoAtual = MENU_PRINCIPAL;
    opcaoMenuPrincipal = 0;
    mostrarMenuPrincipal();
    limparBotoes();
  }
  
  limparBotoes();
}

/**
 * Calcula a média do pH descartando extremos
 */
void calcularMediaPh() {
  if (!arrayPreenchido) return;
  
  // Copiar array para ordenação
  float temp[AMOSTRAS_CALIBRACAO];
  for (int i = 0; i < AMOSTRAS_CALIBRACAO; i++) {
    temp[i] = leiturasPh[i];
  }
  
  // Ordenar
  for (int i = 0; i < AMOSTRAS_CALIBRACAO - 1; i++) {
    for (int j = i + 1; j < AMOSTRAS_CALIBRACAO; j++) {
      if (temp[i] > temp[j]) {
        float aux = temp[i];
        temp[i] = temp[j];
        temp[j] = aux;
      }
    }
  }
  
  // Calcular média sem extremos
  float soma = 0;
  for (int i = DESCARTAR_EXTREMOS; i < AMOSTRAS_CALIBRACAO - DESCARTAR_EXTREMOS; i++) {
    soma += temp[i];
  }
  
  phAtual = soma / (AMOSTRAS_CALIBRACAO - 2 * DESCARTAR_EXTREMOS);
}

/**
 * Verifica se é necessário controle de pH
 */
void verificarControlePh() {
  float diferenca = abs(phAtual - phIdeal);
  
  if (diferenca > PH_TOLERANCE) {
    if (phAtual < phIdeal) {
      // pH abaixo do ideal - acender LED e mostrar alerta
      digitalWrite(PIN_LED, HIGH);
      alertaPh = true;
    } else {
      // pH acima do ideal - ativar bomba se não foi ativada recentemente
      if (tempoAtual - tempoUltimaBomba >= TEMPO_ESPERA_BOMBA) {
        ativarBomba();
      }
    }
  } else {
    // pH dentro do ideal
    digitalWrite(PIN_LED, LOW);
    alertaPh = false;
  }
}

/**
 * Ativa a bomba por um período determinado
 */
void ativarBomba() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("   AJUSTANDO PH");
  
  // Mostrar barra de progresso
  lcd.setCursor(0, 2);
  lcd.print("[");
  for (int i = 0; i < 18; i++) {
    lcd.print(" ");
  }
  lcd.print("]");
  
  digitalWrite(PIN_MOSFET, HIGH); // Ativar bomba
  
  unsigned long inicioAtivacao = millis();
  while (millis() - inicioAtivacao < TEMPO_BOMBA) {
    wdt_reset();
    
    // Atualizar barra de progresso
    int progresso = ((millis() - inicioAtivacao) * 18) / TEMPO_BOMBA;
    lcd.setCursor(1, 2);
    for (int i = 0; i < progresso; i++) {
      lcd.print("=");
    }
    
    delay(50);
  }
  
  digitalWrite(PIN_MOSFET, LOW); // Desativar bomba
  tempoUltimaBomba = millis();
  
  // Mostrar mensagem de conclusão
  lcd.clear();
  lcd.setCursor(0, 1);
  lcd.print("  AJUSTE COMPLETO");
  delay(2000);
  
  mostrarTelaMonitoramento();
}

/**
 * Processa o menu principal
 */
void processarMenuPrincipal() {
  if (btnUpPressed) {
    opcaoMenuPrincipal = (opcaoMenuPrincipal - 1 + 4) % 4;
    mostrarMenuPrincipal();
    limparBotoes();
  }
  
  if (btnDownPressed) {
    opcaoMenuPrincipal = (opcaoMenuPrincipal + 1) % 4;
    mostrarMenuPrincipal();
    limparBotoes();
  }
  
  if (btnMenuPressed) {
    switch (opcaoMenuPrincipal) {
      case 0: // Definir pH Ideal
        estadoAtual = DEFINIR_PH_IDEAL;
        mostrarDefinirPhIdeal();
        break;
      case 1: // Calibrar Sonda
        estadoAtual = CALIBRAR_SONDA;
        mostrarMenuCalibracao();
        break;
      case 2: // Menu Técnico
        estadoAtual = MENU_TECNICO;
        opcaoMenuTecnico = 0;
        mostrarMenuTecnico();
        break;
      case 3: // Voltar
        estadoAtual = MONITORANDO;
        mostrarTelaMonitoramento();
        break;
    }
    limparBotoes();
  }
}

/**
 * Mostra a tela para definir pH ideal
 */
void mostrarDefinirPhIdeal() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("  DEFINIR PH IDEAL");
  lcd.setCursor(0, 2);
  lcd.print("PH Ideal: ");
  lcd.print(phIdeal, 1);
  lcd.setCursor(0, 3);
  lcd.print("Press. MENU p/ salvar");
}

/**
 * Processa a definição de pH ideal
 */
void processarDefinirPhIdeal() {
  if (btnUpPressed) {
    phIdeal += PH_STEP;
    if (phIdeal > PH_MAX) phIdeal = PH_MAX;
    mostrarDefinirPhIdeal();
    limparBotoes();
  }
  
  if (btnDownPressed) {
    phIdeal -= PH_STEP;
    if (phIdeal < PH_MIN) phIdeal = PH_MIN;
    mostrarDefinirPhIdeal();
    limparBotoes();
  }
  
  if (btnMenuPressed) {
    // Salvar na EEPROM
    salvarConfiguracoes();
    
    lcd.clear();
    lcd.setCursor(0, 1);
    lcd.print("  PH IDEAL SALVO!");
    delay(2000);
    
    estadoAtual = MONITORANDO;
    mostrarTelaMonitoramento();
    limparBotoes();
  }
}

/**
 * Mostra o menu de calibração
 */
void mostrarMenuCalibracao() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("  CALIBRAR SONDA");
  
  const char* opcoes[] = {"1 PONTO", "2 PONTOS", "Voltar"};
  
  for (int i = 0; i < 3; i++) {
    lcd.setCursor(0, i + 1);
    if (i == opcaoSolucaoCalPH) {
      lcd.print("> ");
    } else {
      lcd.print("  ");
    }
    lcd.print(opcoes[i]);
  }
}

/**
 * Processa o menu de calibração
 */
void processarMenuCalibracao() {
  if (btnUpPressed) {
    opcaoSolucaoCalPH = (opcaoSolucaoCalPH - 1 + 3) % 3;
    mostrarMenuCalibracao();
    limparBotoes();
  }
  
  if (btnDownPressed) {
    opcaoSolucaoCalPH = (opcaoSolucaoCalPH + 1) % 3;
    mostrarMenuCalibracao();
    limparBotoes();
  }
  
  if (btnMenuPressed) {
    switch (opcaoSolucaoCalPH) {
      case 0: // 1 PONTO
        estadoAtual = CAL_SELECAO_SOL1;
        opcaoSolucaoCalPH = 0;
        mostrarSelecaoSolucao("SELECIONE SOLUCAO:");
        break;
      case 1: // 2 PONTOS
        estadoAtual = CAL_SELECAO_SOL1;
        opcaoSolucaoCalPH = 0;
        mostrarSelecaoSolucao("SELECIONE SOLUCAO 1:");
        break;
      case 2: // Voltar
        estadoAtual = MENU_PRINCIPAL;
        mostrarMenuPrincipal();
        break;
    }
    limparBotoes();
  }
}

/**
 * Mostra a seleção de solução para calibração
 */
void mostrarSelecaoSolucao(const char* titulo) {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(titulo);
  
  for (int i = 0; i < numSolucoes; i++) {
    lcd.setCursor(0, i + 1);
    if (i == opcaoSolucaoCalPH) {
      lcd.print("> ");
    } else {
      lcd.print("  ");
    }
    lcd.print(valoresSolucoes[i], 2);
  }
  
  // Opção Voltar
  lcd.setCursor(0, 3);
  if (opcaoSolucaoCalPH == numSolucoes) {
    lcd.print("> ");
  } else {
    lcd.print("  ");
  }
  lcd.print("Voltar");
}

/**
 * Processa seleção da primeira solução
 */
void processarSelecaoSolucao1() {
  if (btnUpPressed) {
    opcaoSolucaoCalPH = (opcaoSolucaoCalPH - 1 + numSolucoes + 1) % (numSolucoes + 1);
    mostrarSelecaoSolucao("SELECIONE SOLUCAO:");
    limparBotoes();
  }
  
  if (btnDownPressed) {
    opcaoSolucaoCalPH = (opcaoSolucaoCalPH + 1) % (numSolucoes + 1);
    mostrarSelecaoSolucao("SELECIONE SOLUCAO:");
    limparBotoes();
  }
  
  if (btnMenuPressed) {
    if (opcaoSolucaoCalPH < numSolucoes) {
      // Solução selecionada, iniciar calibração
      estadoAtual = CAL_MEDINDO;
      mostrarPreparaCalibracao(valoresSolucoes[opcaoSolucaoCalPH]);
    } else {
      // Voltar
      estadoAtual = CALIBRAR_SONDA;
      mostrarMenuCalibracao();
    }
    limparBotoes();
  }
}

/**
 * Processa seleção da segunda solução (calibração 2 pontos)
 */
void processarSelecaoSolucao2() {
  // Similar à primeira, mas exclui a solução já selecionada
  // Implementação similar à função anterior
  // Para brevidade, implementação simplificada
}

/**
 * Mostra preparação para calibração
 */
void mostrarPreparaCalibracao(float valorSolucao) {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Insira sonda em");
  lcd.setCursor(0, 1);
  lcd.print("solucao pH ");
  lcd.print(valorSolucao, 2);
  lcd.setCursor(0, 3);
  lcd.print("Press MENU qdo pronto");
}

/**
 * Processa o processo de calibração
 */
void processarCalibracao() {
  if (btnMenuPressed) {
    realizarCalibracao();
    limparBotoes();
  }
}

/**
 * Realiza o processo de calibração completo
 */
void realizarCalibracao() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("  CALIBRANDO...");
  
  float media1, media2;
  int tentativas = 0;
  bool sucesso = false;
  
  while (tentativas < MAX_TENTATIVAS_CAL && !sucesso) {
    wdt_reset();
    
    // Primeira média
    lcd.setCursor(0, 1);
    lcd.print("Medindo... 1/2");
    media1 = lerPhComMedia();
    
    // Segunda média
    lcd.setCursor(0, 1);
    lcd.print("Medindo... 2/2");
    media2 = lerPhComMedia();
    
    // Verificar estabilidade
    if (abs(media1 - media2) <= PH_STABILITY) {
      sucesso = true;
      // Calcular offset de calibração
      float valorReferencia = valoresSolucoes[opcaoSolucaoCalPH];
      offsetCalibracao = valorReferencia - ((media1 + media2) / 2.0f);
      
      salvarConfiguracoes();
      
      lcd.clear();
      lcd.setCursor(0, 1);
      lcd.print("CALIBRACAO OK!");
      delay(2000);
    } else {
      tentativas++;
      lcd.setCursor(0, 2);
      lcd.print("Tentativa ");
      lcd.print(tentativas);
      delay(1000);
    }
  }
  
  if (!sucesso) {
    lcd.clear();
    lcd.setCursor(0, 1);
    lcd.print("ERRO CALIBRACAO");
    lcd.setCursor(0, 2);
    lcd.print("Tentar Novamente?");
    delay(3000);
  }
  
  estadoAtual = MONITORANDO;
  mostrarTelaMonitoramento();
}

/**
 * Mostra o menu técnico
 */
void mostrarMenuTecnico() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("   MENU TECNICO");
  
  const char* opcoes[] = {"Valores Brutos", "Checar Sensores", "Reiniciar", "Voltar"};
  
  for (int i = 0; i < 4; i++) {
    lcd.setCursor(0, i + 1);
    if (i == opcaoMenuTecnico) {
      lcd.print("> ");
    } else {
      lcd.print("  ");
    }
    
    if (i < 3) {
      lcd.print(opcoes[i]);
    } else {
      lcd.setCursor(2, 3);
      lcd.print("Voltar");
    }
  }
}

/**
 * Processa o menu técnico
 */
void processarMenuTecnico() {
  if (btnUpPressed) {
    opcaoMenuTecnico = (opcaoMenuTecnico - 1 + 4) % 4;
    mostrarMenuTecnico();
    limparBotoes();
  }
  
  if (btnDownPressed) {
    opcaoMenuTecnico = (opcaoMenuTecnico + 1) % 4;
    mostrarMenuTecnico();
    limparBotoes();
  }
  
  if (btnMenuPressed) {
    switch (opcaoMenuTecnico) {
      case 0: // Valores Brutos
        estadoAtual = VALORES_BRUTOS;
        mostrarValoresBrutos();
        break;
      case 1: // Checar Sensores
        estadoAtual = CHECAR_SENSORES;
        iniciarChecarSensores();
        break;
      case 2: // Reiniciar
        estadoAtual = REINICIAR_SISTEMA;
        mostrarReiniciarSistema();
        break;
      case 3: // Voltar
        estadoAtual = MENU_PRINCIPAL;
        mostrarMenuPrincipal();
        break;
    }
    limparBotoes();
  }
}

/**
 * Mostra valores brutos dos sensores
 */
void mostrarValoresBrutos() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("  VALORES BRUTOS");
  
  tensaoBrutaPh = lerTensaoBrutaPH();
  temperatura = lerTemperatura();
  
  lcd.setCursor(0, 1);
  lcd.print("pH Tensao: ");
  lcd.print(tensaoBrutaPh, 3);
  lcd.print("V");
  
  lcd.setCursor(0, 2);
  lcd.print("Temperatura: ");
  lcd.print(temperatura, 1);
  lcd.print("C");
  
  lcd.setCursor(0, 3);
  lcd.print("MENU = Voltar");
}

/**
 * Processa visualização de valores brutos
 */
void processarValoresBrutos() {
  // Atualizar a cada segundo
  if (tempoAtual - tempoUltimaLeitura >= 1000) {
    mostrarValoresBrutos();
    tempoUltimaLeitura = tempoAtual;
  }
  
  if (btnMenuPressed) {
    estadoAtual = MENU_TECNICO;
    mostrarMenuTecnico();
    limparBotoes();
  }
}

/**
 * Inicia verificação dos sensores
 */
void iniciarChecarSensores() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(" TESTANDO SENSORES");
  lcd.setCursor(0, 1);
  lcd.print("[                  ]");
}

/**
 * Processa verificação dos sensores
 */
void processarChecarSensores() {
  static int etapa = 0;
  static unsigned long tempoInicio = 0;
  
  if (etapa == 0) {
    tempoInicio = millis();
    etapa = 1;
  }
  
  unsigned long tempoDecorrido = millis() - tempoInicio;
  int progresso = (tempoDecorrido * 18) / 5000; // 5 segundos total
  
  if (progresso < 18) {
    lcd.setCursor(1, 1);
    for (int i = 0; i < progresso; i++) {
      lcd.print("=");
    }
  } else {
    // Teste concluído, mostrar resultados
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("RESULTADO DO TESTE:");
    
    // Testar sensor de temperatura
    temperatura = lerTemperatura();
    lcd.setCursor(0, 1);
    if (temperatura > -50 && temperatura < 100) {
      lcd.print("Temp: OK");
    } else {
      lcd.print("Temp: ERRO");
    }
    
    // Testar sensor de pH
    tensaoBrutaPh = lerTensaoBrutaPH();
    lcd.setCursor(11, 1);
    if (tensaoBrutaPh >= 0 && tensaoBrutaPh <= 5.0) {
      lcd.print("pH: OK");
    } else {
      lcd.print("pH:ERRO");
    }
    
    // Testar ADS1115
    lcd.setCursor(0, 2);
    if (ads.isConnected()) {
      lcd.print("ADS1115: OK");
    } else {
      lcd.print("ADS1115: ERRO");
    }
    
    lcd.setCursor(0, 3);
    lcd.print("MENU = Voltar");
    etapa = 0; // Reset para próxima vez
  }
  
  if (btnMenuPressed && progresso >= 18) {
    estadoAtual = MENU_TECNICO;
    mostrarMenuTecnico();
    limparBotoes();
  }
}

/**
 * Mostra opção de reiniciar sistema
 */
void mostrarReiniciarSistema() {
  lcd.clear();
  lcd.setCursor(0, 1);
  lcd.print(" REINICIAR SISTEMA?");
  lcd.setCursor(0, 3);
  lcd.print("UP=SIM   DOWN=NAO");
}

/**
 * Processa opção de reinicialização
 */
void processarReiniciarSistema() {
  if (btnUpPressed) {
    // Reiniciar sistema
    lcd.clear();
    lcd.setCursor(0, 1);
    lcd.print("  REINICIANDO...");
    delay(2000);
    
    // Resetar via watchdog
    wdt_enable(WDTO_15MS);
    while(1) {} // Aguardar reset
    
    limparBotoes();
  }
  
  if (btnDownPressed) {
    // Cancelar
    estadoAtual = MENU_TECNICO;
    mostrarMenuTecnico();
    limparBotoes();
  }
}

// ==================== FUNÇÕES DE EEPROM ====================

/**
 * Carrega configurações da EEPROM
 */
void carregarConfiguracoes() {
  // Verificar se EEPROM foi inicializada
  if (EEPROM.read(EEPROM_INITIALIZED) != 0xAA) {
    // Primeira inicialização - salvar valores padrão
    phIdeal = PH_IDEAL_DEFAULT;
    offsetCalibracao = 0.0f;
    slopeCalibracao = 1.0f;
    salvarConfiguracoes();
  } else {
    // Carregar valores salvos
    EEPROM.get(EEPROM_PH_IDEAL, phIdeal);
    EEPROM.get(EEPROM_CAL_OFFSET, offsetCalibracao);
    EEPROM.get(EEPROM_CAL_SLOPE, slopeCalibracao);
    
    // Verificar se valores são válidos
    if (phIdeal < PH_MIN || phIdeal > PH_MAX) {
      phIdeal = PH_IDEAL_DEFAULT;
    }
    
    Serial.print("Configurações carregadas - pH Ideal: ");
    Serial.println(phIdeal);
  }
}

/**
 * Salva configurações na EEPROM
 */
void salvarConfiguracoes() {
  EEPROM.put(EEPROM_PH_IDEAL, phIdeal);
  EEPROM.put(EEPROM_CAL_OFFSET, offsetCalibracao);
  EEPROM.put(EEPROM_CAL_SLOPE, slopeCalibracao);
  EEPROM.write(EEPROM_INITIALIZED, 0xAA); // Marcar como inicializada
  
  Serial.println("Configurações salvas na EEPROM");
}

// ==================== FUNÇÃO DE TIMEOUT ====================

/**
 * Verifica timeout de inatividade e retorna à tela inicial
 */
void verificarTimeoutInatividade() {
  if (estadoAtual != MONITORANDO && estadoAtual != INICIALIZANDO) {
    if (tempoAtual - tempoUltimaAtividade >= TEMPO_INATIVIDADE) {
      estadoAtual = MONITORANDO;
      mostrarTelaMonitoramento();
    }
  }
}

// ==================== FIM DO CÓDIGO ====================

/*
 * DEPENDÊNCIAS NECESSÁRIAS (instalar via Library Manager do Arduino IDE):
 * 
 * 1. LiquidCrystal_I2C - para controle do display LCD I2C
 *    Autor: Frank de Brabander
 *    
 * 2. OneWire - para comunicação com sensor DS18B20
 *    Autor: Jim Studt, Tom Pollard, Robin James, Paul Stoffregen
 *    
 * 3. DallasTemperature - biblioteca para sensor DS18B20
 *    Autor: Miles Burton, Tim Newsome, Guil Barros, Rob Tillaart
 *    
 * 4. ADS1X15 - biblioteca para conversor A/D ADS1115
 *    Autor: Rob Tillaart
 * 
 * NOTAS DE INSTALAÇÃO:
 * - Todas as bibliotecas podem ser instaladas através do Library Manager
 * - Vá em Sketch > Include Library > Manage Libraries
 * - Busque pelo nome de cada biblioteca e instale
 * - As bibliotecas Wire.h, EEPROM.h e avr/wdt.h já vêm com o Arduino IDE
 * 
 * CONFIGURAÇÃO DO HARDWARE:
 * - Certifique-se de que todos os componentes estão conectados conforme o esquema
 * - O endereço I2C do LCD (0x27) pode variar - use um scanner I2C se necessário
 * - O ADS1115 deve estar configurado no endereço 0x48
 * - Teste cada componente individualmente antes de carregar o código completo
 * 
 * CALIBRAÇÃO INICIAL:
 * - Use soluções buffer de pH certificadas para calibração
 * - Valores recomendados: pH 4.01, 7.01 e 10.01
 * - Sempre calibre com a temperatura próxima à de operação
 * - Mantenha as sondas limpas e armazenadas adequadamente
 */
