/*
 * SISTEMA DE CONTROLE AUTOMÁTICO DE PH PARA CULTIVO HIDROPÔNICO
 * Versão: 1.0
 * Plataforma: Arduino Nano
 * 
 * Este sistema monitora e ajusta automaticamente o pH de uma solução nutritiva
 * usando uma bomba peristáltica para adicionar solução redutora de pH quando necessário.
 * 
 * COMPONENTES PRINCIPAIS:
 * - Arduino Nano
 * - Sensor de pH com módulo analógico
 * - Sensor de temperatura DS18B20
 * - Display LCD 20x4 I2C
 * - ADC ADS1115 16-bit
 * - Bomba peristáltica 5V com driver MOSFET
 * - 3 botões touch (MENU, UP, DOWN)
 * - LED indicador
 */

// ===== BIBLIOTECAS NECESSÁRIAS =====
#include <Wire.h>                    // Comunicação I2C para LCD e ADS1115
#include <LiquidCrystal_I2C.h>      // Controle do display LCD via I2C
#include <Adafruit_ADS1X15.h>       // Leitura do ADC ADS1115
#include <OneWire.h>                // Protocolo OneWire para DS18B20
#include <DallasTemperature.h>      // Biblioteca para sensor DS18B20
#include <EEPROM.h>                 // Armazenamento permanente de configurações
#include <avr/wdt.h>                // Watchdog timer para segurança

// ===== DEFINIÇÃO DE PINOS =====
const uint8_t PIN_TEMP_SENSOR = 2;   // Pino do sensor DS18B20
const uint8_t PIN_BTN_MENU = 3;      // Botão touch MENU
const uint8_t PIN_BTN_DOWN = 4;      // Botão touch DOWN  
const uint8_t PIN_BTN_UP = 5;        // Botão touch UP
const uint8_t PIN_PUMP = 6;          // Controle da bomba (MOSFET)
const uint8_t PIN_LED = 7;           // LED indicador de pH baixo

// ===== CONFIGURAÇÕES DO SISTEMA =====
const float PH_MIN = 1.0;            // pH mínimo configurável
const float PH_MAX = 13.0;           // pH máximo configurável
const float PH_STEP = 0.1;           // Incremento do ajuste de pH
const float PH_DEFAULT = 7.0;        // pH padrão inicial
const float PH_TOLERANCE = 0.3;      // Tolerância para variação de pH
const float PH_STABILITY = 0.1;      // Variação máxima para considerar estável

// ===== TEMPOS E INTERVALOS (em milissegundos) =====
const unsigned long SENSOR_STABILIZE_TIME = 3000;   // Tempo de estabilização inicial
const unsigned long SAMPLE_INTERVAL = 1000;         // Intervalo entre leituras
const unsigned long MENU_TIMEOUT = 30000;           // Timeout do menu (30s)
const unsigned long PUMP_DURATION = 1000;           // Duração do acionamento da bomba
const unsigned long PUMP_WAIT_TIME = 300000;        // Tempo de espera entre ajustes (5min)
const unsigned long DISPLAY_UPDATE_INTERVAL = 500;  // Atualização do display

// ===== CONFIGURAÇÕES DE CALIBRAÇÃO =====
const uint8_t NUM_SAMPLES = 15;      // Número de amostras para média
const uint8_t NUM_DISCARD = 2;       // Número de extremos a descartar (cada lado)
const uint8_t MAX_CAL_ATTEMPTS = 5;  // Máximo de tentativas de calibração
const float CAL_TOLERANCE = 0.1;     // Tolerância para validar calibração

// ===== ENDEREÇOS EEPROM =====
const int EEPROM_PH_IDEAL = 0;       // Endereço do pH ideal (float = 4 bytes)
const int EEPROM_CAL_OFFSET = 4;     // Endereço do offset de calibração
const int EEPROM_CAL_SLOPE = 8;      // Endereço do slope de calibração
const int EEPROM_CALIBRATED = 12;    // Flag de calibração válida
const int EEPROM_MAGIC = 13;         // Número mágico para validar EEPROM

// ===== CONSTANTES DE CALIBRAÇÃO =====
const float PH_VOLTAGE_NEUTRAL = 1.5;  // Voltagem em pH 7.0 (típico)
const float PH_VOLTAGE_PER_PH = -0.18; // Mudança de voltagem por unidade de pH
const uint8_t EEPROM_MAGIC_NUMBER = 42; // Valor para verificar EEPROM válida

// ===== ESTADOS DO MENU =====
enum MenuState {
    MENU_NONE,           // Tela inicial de monitoramento
    MENU_INITIAL,        // Menu inicial (ao ligar)
    MENU_MAIN,          // Menu principal
    MENU_SET_PH,        // Definir pH ideal
    MENU_CALIBRATE,     // Menu de calibração
    MENU_CAL_1POINT,    // Calibração 1 ponto
    MENU_CAL_2POINTS,   // Calibração 2 pontos
    MENU_TECHNICAL,     // Menu técnico
    MENU_RAW_VALUES,    // Valores brutos
    MENU_CHECK_SENSORS, // Verificar sensores
    MENU_RESTART        // Reiniciar sistema
};

// ===== ESTRUTURA DE CALIBRAÇÃO =====
struct CalibrationData {
    float offset;        // Offset da calibração
    float slope;         // Slope para conversão
    bool isValid;        // Flag de calibração válida
    float solution1;     // Valor da primeira solução
    float solution2;     // Valor da segunda solução (2 pontos)
};

// ===== OBJETOS GLOBAIS =====
LiquidCrystal_I2C lcd(0x27, 20, 4);        // LCD 20x4 no endereço 0x27
Adafruit_ADS1115 ads;                       // ADC ADS1115
OneWire oneWire(PIN_TEMP_SENSOR);           // Barramento OneWire
DallasTemperature tempSensor(&oneWire);     // Sensor de temperatura

// ===== VARIÁVEIS GLOBAIS =====
MenuState currentMenu = MENU_NONE;          // Estado atual do menu
MenuState lastMenu = MENU_NONE;             // Estado anterior do menu
float phIdeal = PH_DEFAULT;                 // pH ideal configurado
float currentPH = 7.0;                      // pH atual (média)
float instantPH = 7.0;                      // pH instantâneo
float currentTemp = 25.0;                   // Temperatura atual
CalibrationData calibration;                // Dados de calibração
unsigned long lastMenuActivity = 0;         // Tempo da última atividade no menu
unsigned long lastPumpActivation = 0;       // Tempo do último ajuste
unsigned long lastSampleTime = 0;           // Tempo da última amostra
unsigned long lastDisplayUpdate = 0;        // Última atualização do display
uint8_t sampleCount = 0;                    // Contador de amostras
float samples[NUM_SAMPLES];                 // Buffer de amostras
uint8_t menuSelection = 0;                  // Item selecionado no menu
uint8_t spinnerState = 0;                   // Estado da animação giratória
bool pumpActive = false;                    // Estado da bomba
bool ledState = false;                      // Estado do LED
float lastStablePH = 7.0;                   // Último pH estável registrado
uint8_t stabilityCount = 0;                 // Contador de estabilidade

// ===== CARACTERES CUSTOMIZADOS PARA LCD =====
byte spinnerChars[4][8] = {
    {0x00, 0x0E, 0x11, 0x11, 0x11, 0x11, 0x0E, 0x00},  // O
    {0x00, 0x06, 0x09, 0x11, 0x11, 0x09, 0x06, 0x00},  // o cima
    {0x00, 0x00, 0x0E, 0x11, 0x11, 0x0E, 0x00, 0x00},  // -
    {0x00, 0x0C, 0x12, 0x11, 0x11, 0x12, 0x0C, 0x00}   // o baixo
};

// ===== FUNÇÕES DE INICIALIZAÇÃO =====

/*
 * setup() - Função de inicialização do Arduino
 * Configura todos os componentes e carrega configurações salvas
 */
void setup() {
    // Habilita o watchdog para 2 segundos
    wdt_enable(WDTO_2S);
    
    // Inicializa comunicação serial para debug
    Serial.begin(115200);
    Serial.println(F("Iniciando Sistema de Controle de pH..."));
    
    // Configura pinos
    pinMode(PIN_BTN_MENU, INPUT_PULLUP);
    pinMode(PIN_BTN_DOWN, INPUT_PULLUP);
    pinMode(PIN_BTN_UP, INPUT_PULLUP);
    pinMode(PIN_PUMP, OUTPUT);
    pinMode(PIN_LED, OUTPUT);
    
    // Estados iniciais
    digitalWrite(PIN_PUMP, LOW);
    digitalWrite(PIN_LED, LOW);
    
    // Inicializa LCD
    lcd.init();
    lcd.backlight();
    lcd.clear();
    
    // Cria caracteres customizados
    for (int i = 0; i < 4; i++) {
        lcd.createChar(i, spinnerChars[i]);
    }
    
    // Mensagem de inicialização
    lcd.setCursor(2, 1);
    lcd.print(F("SISTEMA DE pH"));
    lcd.setCursor(3, 2);
    lcd.print(F("Iniciando..."));
    
    // Inicializa I2C e ADS1115
    Wire.begin();
    if (!ads.begin()) {
        lcd.clear();
        lcd.setCursor(0, 1);
        lcd.print(F("ERRO: ADS1115"));
        lcd.setCursor(0, 2);
        lcd.print(F("nao encontrado!"));
        while (1) {
            wdt_reset();
            delay(100);
        }
    }
    
    // Configura ganho do ADS1115 (±4.096V)
    ads.setGain(GAIN_ONE);
    
    // Inicializa sensor de temperatura
    tempSensor.begin();
    tempSensor.setResolution(12); // Resolução de 12 bits
    
    // Carrega configurações da EEPROM
    loadSettings();
    
    // Aguarda estabilização dos sensores
    lcd.clear();
    lcd.setCursor(1, 1);
    lcd.print(F("Estabilizando"));
    lcd.setCursor(4, 2);
    lcd.print(F("Sensores..."));
    
    unsigned long startTime = millis();
    while (millis() - startTime < SENSOR_STABILIZE_TIME) {
        wdt_reset();
        // Animação de espera
        lcd.setCursor(18, 2);
        lcd.write((millis() / 250) % 4);
        delay(50);
    }
    
    // Exibe menu inicial
    currentMenu = MENU_INITIAL;
    displayInitialMenu();
    
    Serial.println(F("Sistema iniciado com sucesso!"));
}

// ===== LOOP PRINCIPAL =====

/*
 * loop() - Função principal do Arduino
 * Gerencia o fluxo do programa e mantém o watchdog ativo
 */
void loop() {
    // Reset do watchdog - MUITO IMPORTANTE!
    wdt_reset();
    
    // Processa botões
    handleButtons();
    
    // Verifica timeout do menu
    if (currentMenu != MENU_NONE && currentMenu != MENU_INITIAL) {
        if (millis() - lastMenuActivity > MENU_TIMEOUT) {
            currentMenu = MENU_NONE;
            lcd.clear();
        }
    }
    
    // Processa estado atual
    switch (currentMenu) {
        case MENU_NONE:
            monitoringScreen();
            break;
        case MENU_INITIAL:
            // Menu inicial já está exibido
            break;
        case MENU_MAIN:
            displayMainMenu();
            break;
        case MENU_SET_PH:
            setPhIdealScreen();
            break;
        case MENU_CALIBRATE:
            displayCalibrateMenu();
            break;
        case MENU_CAL_1POINT:
            calibrate1Point();
            break;
        case MENU_CAL_2POINTS:
            calibrate2Points();
            break;
        case MENU_TECHNICAL:
            displayTechnicalMenu();
            break;
        case MENU_RAW_VALUES:
            displayRawValues();
            break;
        case MENU_CHECK_SENSORS:
            checkSensors();
            break;
        case MENU_RESTART:
            restartSystem();
            break;
    }
}

// ===== FUNÇÕES DE LEITURA DE SENSORES =====

/*
 * readPhVoltage() - Lê a voltagem do sensor de pH
 * Retorna: Voltagem em volts
 */
float readPhVoltage() {
    int16_t adc = ads.readADC_SingleEnded(0);
    float voltage = ads.computeVolts(adc);
    return voltage;
}

/*
 * readTemperature() - Lê a temperatura do sensor DS18B20
 * Retorna: Temperatura em graus Celsius
 */
float readTemperature() {
    tempSensor.requestTemperatures();
    float temp = tempSensor.getTempCByIndex(0);
    
    // Verifica se a leitura é válida
    if (temp == DEVICE_DISCONNECTED_C) {
        return 25.0; // Retorna temperatura padrão se erro
    }
    
    return temp;
}

/*
 * voltageToPH() - Converte voltagem em valor de pH
 * Parâmetros:
 *   voltage: Voltagem lida do sensor
 *   temp: Temperatura atual para compensação
 * Retorna: Valor de pH calculado
 */
float voltageToPH(float voltage, float temp) {
    // Compensação de temperatura (0.003 pH/°C)
    float tempCompensation = (temp - 25.0) * 0.003;
    
    float ph;
    if (calibration.isValid) {
        // Usa calibração personalizada
        ph = calibration.offset + (voltage * calibration.slope);
    } else {
        // Usa valores padrão
        ph = 7.0 + ((PH_VOLTAGE_NEUTRAL - voltage) / PH_VOLTAGE_PER_PH);
    }
    
    // Aplica compensação de temperatura
    ph += tempCompensation;
    
    // Limita o valor entre 0 e 14
    ph = constrain(ph, 0.0, 14.0);
    
    return ph;
}

/*
 * takeSamples() - Coleta amostras de pH e calcula média
 * Parâmetros:
 *   numSamples: Número de amostras a coletar
 *   showProgress: Se deve mostrar progresso no LCD
 * Retorna: Média das amostras após descartar extremos
 */
float takeSamples(uint8_t numSamples, bool showProgress = false) {
    float localSamples[numSamples];
    
    for (uint8_t i = 0; i < numSamples; i++) {
        wdt_reset();
        
        float voltage = readPhVoltage();
        float temp = readTemperature();
        localSamples[i] = voltageToPH(voltage, temp);
        
        if (showProgress) {
            lcd.setCursor(0, 3);
            lcd.print(F("Amostra "));
            lcd.print(i + 1);
            lcd.print(F("/"));
            lcd.print(numSamples);
            lcd.print(F("  "));
        }
        
        delay(SAMPLE_INTERVAL);
    }
    
    // Ordena as amostras
    sortArray(localSamples, numSamples);
    
    // Calcula média descartando extremos
    float sum = 0;
    uint8_t validSamples = 0;
    
    for (uint8_t i = NUM_DISCARD; i < numSamples - NUM_DISCARD; i++) {
        sum += localSamples[i];
        validSamples++;
    }
    
    return sum / validSamples;
}

/*
 * sortArray() - Ordena array usando bubble sort
 * Parâmetros:
 *   arr: Array a ser ordenado
 *   size: Tamanho do array
 */
void sortArray(float arr[], uint8_t size) {
    for (uint8_t i = 0; i < size - 1; i++) {
        for (uint8_t j = 0; j < size - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                float temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// ===== FUNÇÕES DE INTERFACE =====

/*
 * handleButtons() - Processa entrada dos botões
 * Detecta pressionamento e executa ações apropriadas
 */
void handleButtons() {
    static unsigned long lastButtonPress = 0;
    static bool menuPressed = false;
    static bool upPressed = false;
    static bool downPressed = false;
    
    // Debounce de 200ms
    if (millis() - lastButtonPress < 200) {
        return;
    }
    
    // Lê estado dos botões (LOW = pressionado devido ao pullup)
    bool menuNow = (digitalRead(PIN_BTN_MENU) == LOW);
    bool upNow = (digitalRead(PIN_BTN_UP) == LOW);
    bool downNow = (digitalRead(PIN_BTN_DOWN) == LOW);
    
    // Detecta borda de descida (botão pressionado)
    if (menuNow && !menuPressed) {
        lastButtonPress = millis();
        lastMenuActivity = millis();
        menuPressed = true;
        onMenuButton();
    } else if (!menuNow) {
        menuPressed = false;
    }
    
    if (upNow && !upPressed) {
        lastButtonPress = millis();
        lastMenuActivity = millis();
        upPressed = true;
        onUpButton();
    } else if (!upNow) {
        upPressed = false;
    }
    
    if (downNow && !downPressed) {
        lastButtonPress = millis();
        lastMenuActivity = millis();
        downPressed = true;
        onDownButton();
    } else if (!downNow) {
        downPressed = false;
    }
}

/*
 * onMenuButton() - Ação do botão MENU
 */
void onMenuButton() {
    switch (currentMenu) {
        case MENU_NONE:
            currentMenu = MENU_MAIN;
            menuSelection = 0;
            lcd.clear();
            break;
        case MENU_INITIAL:
            executeInitialMenuSelection();
            break;
        case MENU_MAIN:
            executeMainMenuSelection();
            break;
        case MENU_SET_PH:
            savePhIdeal();
            break;
        case MENU_CALIBRATE:
            executeCalibrateMenuSelection();
            break;
        case MENU_TECHNICAL:
            executeTechnicalMenuSelection();
            break;
        case MENU_RAW_VALUES:
        case MENU_CHECK_SENSORS:
            currentMenu = MENU_TECHNICAL;
            menuSelection = 0;
            lcd.clear();
            break;
        case MENU_RESTART:
            if (menuSelection == 0) { // SIM
                resetSystem();
            } else { // NÃO
                currentMenu = MENU_TECHNICAL;
                menuSelection = 0;
                lcd.clear();
            }
            break;
    }
}

/*
 * onUpButton() - Ação do botão UP
 */
void onUpButton() {
    switch (currentMenu) {
        case MENU_INITIAL:
        case MENU_MAIN:
        case MENU_CALIBRATE:
        case MENU_TECHNICAL:
            if (menuSelection > 0) {
                menuSelection--;
                lcd.clear();
            }
            break;
        case MENU_SET_PH:
            if (phIdeal < PH_MAX) {
                phIdeal += PH_STEP;
                if (phIdeal > PH_MAX) phIdeal = PH_MAX;
            }
            break;
        case MENU_RESTART:
            menuSelection = (menuSelection == 0) ? 1 : 0;
            lcd.clear();
            break;
    }
}

/*
 * onDownButton() - Ação do botão DOWN  
 */
void onDownButton() {
    uint8_t maxItems = 0;
    
    switch (currentMenu) {
        case MENU_INITIAL:
            maxItems = 2; // 3 opções (0-2)
            break;
        case MENU_MAIN:
        case MENU_CALIBRATE:
        case MENU_TECHNICAL:
            maxItems = 3; // 4 opções (0-3)
            break;
        case MENU_SET_PH:
            if (phIdeal > PH_MIN) {
                phIdeal -= PH_STEP;
                if (phIdeal < PH_MIN) phIdeal = PH_MIN;
            }
            break;
        case MENU_RESTART:
            menuSelection = (menuSelection == 0) ? 1 : 0;
            lcd.clear();
            break;
    }
    
    if (currentMenu == MENU_INITIAL || currentMenu == MENU_MAIN || 
        currentMenu == MENU_CALIBRATE || currentMenu == MENU_TECHNICAL) {
        if (menuSelection < maxItems) {
            menuSelection++;
            lcd.clear();
        }
    }
}

// ===== TELAS DO SISTEMA =====

/*
 * monitoringScreen() - Tela principal de monitoramento
 * Exibe valores de pH, temperatura e status do sistema
 */
void monitoringScreen() {
    static unsigned long lastPhUpdate = 0;
    static uint8_t currentSample = 0;
    static float phSamples[NUM_SAMPLES];
    static bool collectingSamples = false;
    
    // Atualiza display
    if (millis() - lastDisplayUpdate > DISPLAY_UPDATE_INTERVAL) {
        lastDisplayUpdate = millis();
        
        lcd.setCursor(0, 0);
        lcd.print(F("MONITORANDO "));
        lcd.write(spinnerState);
        spinnerState = (spinnerState + 1) % 4;
        
        // Verifica se pH está abaixo do ideal
        if (currentPH < (phIdeal - PH_TOLERANCE)) {
            lcd.print(F(" BAIXO!"));
            digitalWrite(PIN_LED, HIGH);
            ledState = true;
        } else {
            lcd.print(F("      "));
            digitalWrite(PIN_LED, LOW);
            ledState = false;
        }
        
        lcd.setCursor(0, 1);
        lcd.print(F("PH ATUAL: "));
        lcd.print(currentPH, 1);
        lcd.print(F("  "));
        
        lcd.setCursor(0, 2);
        lcd.print(F("PH INST: "));
        lcd.print(instantPH, 2);
        lcd.print(F("  "));
        
        lcd.setCursor(0, 3);
        lcd.print(F("Temp:"));
        lcd.print(currentTemp, 1);
        lcd.print((char)223); // Símbolo de grau
        lcd.print(F("C"));
        
        lcd.setCursor(11, 3);
        lcd.print(F("Ideal:"));
        lcd.print(phIdeal, 1);
    }
    
    // Coleta amostras de pH
    if (millis() - lastSampleTime > SAMPLE_INTERVAL) {
        lastSampleTime = millis();
        
        // Lê valores atuais
        float voltage = readPhVoltage();
        currentTemp = readTemperature();
        instantPH = voltageToPH(voltage, currentTemp);
        
        // Adiciona amostra ao buffer
        phSamples[currentSample] = instantPH;
        currentSample++;
        
        // Quando completar 15 amostras, calcula média
        if (currentSample >= NUM_SAMPLES) {
            currentSample = 0;
            
            // Copia e ordena amostras
            float tempSamples[NUM_SAMPLES];
            for (uint8_t i = 0; i < NUM_SAMPLES; i++) {
                tempSamples[i] = phSamples[i];
            }
            sortArray(tempSamples, NUM_SAMPLES);
            
            // Calcula média descartando extremos
            float sum = 0;
            uint8_t validSamples = 0;
            for (uint8_t i = NUM_DISCARD; i < NUM_SAMPLES - NUM_DISCARD; i++) {
                sum += tempSamples[i];
                validSamples++;
            }
            
            float newPH = sum / validSamples;
            
            // Verifica estabilidade e necessidade de ajuste
            checkPhStability(newPH);
            
            currentPH = newPH;
        }
    }
}

/*
 * checkPhStability() - Verifica estabilidade do pH e aciona bomba se necessário
 * Parâmetro: newPH - novo valor de pH calculado
 */
void checkPhStability(float newPH) {
    static float stableReadings[3];
    static uint8_t stableIndex = 0;
    static bool checkingStability = false;
    
    // Verifica se há variação significativa
    if (abs(newPH - lastStablePH) > PH_TOLERANCE) {
        checkingStability = true;
        stableReadings[stableIndex] = newPH;
        stableIndex = (stableIndex + 1) % 3;
        stabilityCount++;
        
        // Se temos 3 leituras estáveis
        if (stabilityCount >= 3) {
            // Verifica se as 3 leituras são consistentes
            float maxDiff = 0;
            for (uint8_t i = 0; i < 3; i++) {
                for (uint8_t j = i + 1; j < 3; j++) {
                    float diff = abs(stableReadings[i] - stableReadings[j]);
                    if (diff > maxDiff) maxDiff = diff;
                }
            }
            
            if (maxDiff <= PH_STABILITY) {
                // pH está estável, toma ação
                lastStablePH = newPH;
                
                // Se pH está acima do ideal e bomba pode ser acionada
                if (newPH > (phIdeal + PH_TOLERANCE)) {
                    if (millis() - lastPumpActivation > PUMP_WAIT_TIME) {
                        activatePump();
                    }
                }
                
                checkingStability = false;
                stabilityCount = 0;
            }
        }
    } else {
        // pH está estável
        checkingStability = false;
        stabilityCount = 0;
        lastStablePH = newPH;
    }
}

/*
 * activatePump() - Aciona a bomba peristáltica
 * Exibe progresso no LCD durante o processo
 */
void activatePump() {
    lcd.clear();
    lcd.setCursor(3, 1);
    lcd.print(F("AJUSTANDO PH"));
    
    // Barra de progresso
    lcd.setCursor(2, 2);
    lcd.print(F("[                ]"));
    
    digitalWrite(PIN_PUMP, HIGH);
    pumpActive = true;
    
    unsigned long pumpStart = millis();
    uint8_t progress = 0;
    
    while (millis() - pumpStart < PUMP_DURATION) {
        wdt_reset();
        
        // Atualiza barra de progresso
        uint8_t newProgress = ((millis() - pumpStart) * 16) / PUMP_DURATION;
        if (newProgress > progress) {
            progress = newProgress;
            lcd.setCursor(3, 2);
            for (uint8_t i = 0; i < progress; i++) {
                lcd.print("=");
            }
        }
        
        delay(50);
    }
    
    digitalWrite(PIN_PUMP, LOW);
    pumpActive = false;
    lastPumpActivation = millis();
    
    lcd.clear();
    lcd.setCursor(2, 1);
    lcd.print(F("AJUSTE COMPLETO"));
    delay(2000);
    
    lcd.clear();
}

/*
 * displayInitialMenu() - Exibe menu inicial do sistema
 */
void displayInitialMenu() {
    lcd.clear();
    lcd.setCursor(3, 0);
    lcd.print(F("MENU INICIAL"));
    
    lcd.setCursor(2, 1);
    if (menuSelection == 0) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("Monitorar"));
    
    lcd.setCursor(2, 2);
    if (menuSelection == 1) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("Calibrar Sonda"));
    
    lcd.setCursor(2, 3);
    if (menuSelection == 2) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("Menu Tecnico"));
}

/*
 * executeInitialMenuSelection() - Executa opção selecionada no menu inicial
 */
void executeInitialMenuSelection() {
    switch (menuSelection) {
        case 0: // Monitorar
            currentMenu = MENU_NONE;
            lcd.clear();
            break;
        case 1: // Calibrar Sonda
            currentMenu = MENU_CALIBRATE;
            menuSelection = 0;
            lcd.clear();
            break;
        case 2: // Menu Técnico
            currentMenu = MENU_TECHNICAL;
            menuSelection = 0;
            lcd.clear();
            break;
    }
}

/*
 * displayMainMenu() - Exibe menu principal
 */
void displayMainMenu() {
    lcd.setCursor(2, 0);
    lcd.print(F("MENU PRINCIPAL"));
    
    lcd.setCursor(1, 1);
    if (menuSelection == 0) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("Definir PH Ideal"));
    
    lcd.setCursor(1, 2);
    if (menuSelection == 1) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("Calibrar Sonda"));
    
    lcd.setCursor(1, 3);
    if (menuSelection == 2) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("Menu Tecnico"));
    
    lcd.setCursor(14, 3);
    if (menuSelection == 3) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("Voltar"));
}

/*
 * executeMainMenuSelection() - Executa opção do menu principal
 */
void executeMainMenuSelection() {
    switch (menuSelection) {
        case 0: // Definir pH Ideal
            currentMenu = MENU_SET_PH;
            lcd.clear();
            break;
        case 1: // Calibrar Sonda
            currentMenu = MENU_CALIBRATE;
            menuSelection = 0;
            lcd.clear();
            break;
        case 2: // Menu Técnico
            currentMenu = MENU_TECHNICAL;
            menuSelection = 0;
            lcd.clear();
            break;
        case 3: // Voltar
            currentMenu = MENU_NONE;
            lcd.clear();
            break;
    }
}

/*
 * setPhIdealScreen() - Tela de configuração do pH ideal
 */
void setPhIdealScreen() {
    lcd.setCursor(1, 0);
    lcd.print(F("DEFINIR PH IDEAL"));
    
    lcd.setCursor(2, 1);
    lcd.print(F("PH Ideal: "));
    lcd.print(phIdeal, 1);
    lcd.print(F("  "));
    
    lcd.setCursor(0, 3);
    lcd.print(F("Press. MENU p/ salvar"));
}

/*
 * savePhIdeal() - Salva o pH ideal na EEPROM
 */
void savePhIdeal() {
    EEPROM.put(EEPROM_PH_IDEAL, phIdeal);
    
    lcd.clear();
    lcd.setCursor(5, 1);
    lcd.print(F("PH IDEAL"));
    lcd.setCursor(6, 2);
    lcd.print(F("SALVO!"));
    delay(1500);
    
    currentMenu = MENU_MAIN;
    menuSelection = 0;
    lcd.clear();
}

/*
 * displayCalibrateMenu() - Exibe menu de calibração
 */
void displayCalibrateMenu() {
    lcd.setCursor(2, 0);
    lcd.print(F("CALIBRAR SONDA"));
    
    lcd.setCursor(2, 1);
    if (menuSelection == 0) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("1 PONTO"));
    
    lcd.setCursor(2, 2);
    if (menuSelection == 1) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("2 PONTOS"));
    
    lcd.setCursor(2, 3);
    if (menuSelection == 2) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("Voltar"));
}

/*
 * executeCalibrateMenuSelection() - Executa opção do menu de calibração
 */
void executeCalibrateMenuSelection() {
    switch (menuSelection) {
        case 0: // 1 Ponto
            currentMenu = MENU_CAL_1POINT;
            menuSelection = 0;
            lcd.clear();
            startCalibration1Point();
            break;
        case 1: // 2 Pontos
            currentMenu = MENU_CAL_2POINTS;
            menuSelection = 0;
            lcd.clear();
            startCalibration2Points();
            break;
        case 2: // Voltar
            currentMenu = MENU_MAIN;
            menuSelection = 0;
            lcd.clear();
            break;
    }
}

/*
 * calibrate1Point() - Processo de calibração de 1 ponto
 */
void calibrate1Point() {
    // Implementação detalhada em startCalibration1Point()
}

/*
 * startCalibration1Point() - Inicia calibração de 1 ponto
 */
void startCalibration1Point() {
    static uint8_t calStep = 0;
    static float selectedSolution = 0;
    
    if (calStep == 0) {
        // Seleciona solução
        lcd.setCursor(0, 0);
        lcd.print(F("Selecione SOLUCAO:"));
        
        lcd.setCursor(2, 1);
        if (menuSelection == 0) lcd.print(">");
        else lcd.print(" ");
        lcd.print(F("4.01"));
        
        lcd.setCursor(2, 2);
        if (menuSelection == 1) lcd.print(">");
        else lcd.print(" ");
        lcd.print(F("7.01"));
        
        lcd.setCursor(2, 3);
        if (menuSelection == 2) lcd.print(">");
        else lcd.print(" ");
        lcd.print(F("10.01"));
        
        lcd.setCursor(14, 3);
        if (menuSelection == 3) lcd.print(">");
        else lcd.print(" ");
        lcd.print(F("Voltar"));
        
        // Aguarda seleção
        static bool waitingSelection = true;
        if (waitingSelection) {
            // Será processado pelo botão MENU
            return;
        }
    }
    
    // Quando usuário pressionar MENU, prossegue
    switch (menuSelection) {
        case 0:
            selectedSolution = 4.01;
            break;
        case 1:
            selectedSolution = 7.01;
            break;
        case 2:
            selectedSolution = 10.01;
            break;
        case 3:
            currentMenu = MENU_CALIBRATE;
            menuSelection = 0;
            lcd.clear();
            return;
    }
    
    // Executa calibração
    performCalibration1Point(selectedSolution);
}

/*
 * performCalibration1Point() - Executa o processo de calibração de 1 ponto
 * Parâmetro: solution - valor de pH da solução padrão
 */
void performCalibration1Point(float solution) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F("Insira sonda na"));
    lcd.setCursor(0, 1);
    lcd.print(F("solucao pH "));
    lcd.print(solution, 2);
    lcd.setCursor(0, 3);
    lcd.print(F("MENU quando pronto"));
    
    // Aguarda usuário pressionar MENU
    while (digitalRead(PIN_BTN_MENU) == HIGH) {
        wdt_reset();
        delay(50);
    }
    
    lcd.clear();
    lcd.setCursor(2, 0);
    lcd.print(F("CALIBRANDO..."));
    
    bool calibrationSuccess = false;
    float validAverage = 0;
    
    for (uint8_t attempt = 0; attempt < MAX_CAL_ATTEMPTS; attempt++) {
        // Primeira média
        float avg1 = takeSamples(NUM_SAMPLES, true);
        
        // Segunda média
        float avg2 = takeSamples(NUM_SAMPLES, true);
        
        // Verifica diferença
        if (abs(avg1 - avg2) <= CAL_TOLERANCE) {
            validAverage = (avg1 + avg2) / 2.0;
            calibrationSuccess = true;
            break;
        }
        
        // Mantém a média mais recente para próxima comparação
        avg1 = avg2;
    }
    
    if (calibrationSuccess) {
        // Calcula novo offset baseado na leitura
        float voltage = readPhVoltage();
        calibration.offset = solution - voltage;
        calibration.slope = 1.0; // Slope padrão para 1 ponto
        calibration.isValid = true;
        
        // Salva na EEPROM
        EEPROM.put(EEPROM_CAL_OFFSET, calibration.offset);
        EEPROM.put(EEPROM_CAL_SLOPE, calibration.slope);
        EEPROM.put(EEPROM_CALIBRATED, (uint8_t)1);
        
        lcd.clear();
        lcd.setCursor(3, 1);
        lcd.print(F("CALIBRACAO"));
        lcd.setCursor(3, 2);
        lcd.print(F("CONCLUIDA!"));
        delay(2000);
        
        currentMenu = MENU_NONE;
        lcd.clear();
    } else {
        // Erro na calibração
        lcd.clear();
        lcd.setCursor(4, 1);
        lcd.print(F("ERRO DE"));
        lcd.setCursor(2, 2);
        lcd.print(F("CALIBRACAO!"));
        
        lcd.setCursor(1, 3);
        lcd.print(F("<Voltar  Tentar>"));
        
        // Aguarda decisão do usuário
        while (true) {
            wdt_reset();
            
            if (digitalRead(PIN_BTN_DOWN) == LOW) {
                // Voltar
                currentMenu = MENU_CALIBRATE;
                menuSelection = 0;
                lcd.clear();
                break;
            }
            
            if (digitalRead(PIN_BTN_UP) == LOW) {
                // Tentar novamente
                performCalibration1Point(solution);
                break;
            }
            
            delay(50);
        }
    }
}

/*
 * calibrate2Points() - Processo de calibração de 2 pontos
 */
void calibrate2Points() {
    // Implementação similar à calibração 1 ponto, mas com 2 soluções
    startCalibration2Points();
}

/*
 * startCalibration2Points() - Inicia calibração de 2 pontos
 */
void startCalibration2Points() {
    static float solution1 = 0;
    static float solution2 = 0;
    static uint8_t step = 0;
    
    if (step == 0) {
        // Seleciona primeira solução
        lcd.setCursor(0, 0);
        lcd.print(F("Primeira SOLUCAO:"));
        
        lcd.setCursor(2, 1);
        if (menuSelection == 0) lcd.print(">");
        else lcd.print(" ");
        lcd.print(F("4.01"));
        
        lcd.setCursor(2, 2);
        if (menuSelection == 1) lcd.print(">");
        else lcd.print(" ");
        lcd.print(F("7.01"));
        
        lcd.setCursor(2, 3);
        if (menuSelection == 2) lcd.print(">");
        else lcd.print(" ");
        lcd.print(F("10.01"));
        
        // Processo similar ao 1 ponto, mas coleta 2 soluções
    }
    
    // Implementação completa seria muito extensa
    // Por brevidade, mostrarei a lógica principal
    performCalibration2Points(4.01, 10.01); // Exemplo
}

/*
 * performCalibration2Points() - Executa calibração de 2 pontos
 * Calcula slope e offset baseado em duas leituras
 */
void performCalibration2Points(float sol1, float sol2) {
    float voltage1, voltage2;
    float avgPh1, avgPh2;
    
    // Coleta primeira solução
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F("Solucao 1: pH "));
    lcd.print(sol1);
    
    // Processo similar ao 1 ponto para primeira solução
    avgPh1 = takeSamples(NUM_SAMPLES, true);
    voltage1 = readPhVoltage();
    
    // Coleta segunda solução
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F("Solucao 2: pH "));
    lcd.print(sol2);
    
    avgPh2 = takeSamples(NUM_SAMPLES, true);
    voltage2 = readPhVoltage();
    
    // Calcula slope e offset
    calibration.slope = (sol2 - sol1) / (voltage2 - voltage1);
    calibration.offset = sol1 - (calibration.slope * voltage1);
    calibration.isValid = true;
    
    // Salva calibração
    EEPROM.put(EEPROM_CAL_OFFSET, calibration.offset);
    EEPROM.put(EEPROM_CAL_SLOPE, calibration.slope);
    EEPROM.put(EEPROM_CALIBRATED, (uint8_t)1);
    
    lcd.clear();
    lcd.setCursor(3, 1);
    lcd.print(F("CALIBRACAO"));
    lcd.setCursor(3, 2);  
    lcd.print(F("2 PONTOS OK!"));
    delay(2000);
    
    currentMenu = MENU_NONE;
    lcd.clear();
}

/*
 * displayTechnicalMenu() - Exibe menu técnico
 */
void displayTechnicalMenu() {
    lcd.setCursor(3, 0);
    lcd.print(F("MENU TECNICO"));
    
    lcd.setCursor(1, 1);
    if (menuSelection == 0) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("Valores Brutos"));
    
    lcd.setCursor(1, 2);
    if (menuSelection == 1) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("Checar Sensores"));
    
    lcd.setCursor(1, 3);
    if (menuSelection == 2) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("Reiniciar"));
    
    lcd.setCursor(14, 3);
    if (menuSelection == 3) lcd.print(">");
    else lcd.print(" ");
    lcd.print(F("Voltar"));
}

/*
 * executeTechnicalMenuSelection() - Executa opção do menu técnico
 */
void executeTechnicalMenuSelection() {
    switch (menuSelection) {
        case 0: // Valores Brutos
            currentMenu = MENU_RAW_VALUES;
            lcd.clear();
            break;
        case 1: // Checar Sensores
            currentMenu = MENU_CHECK_SENSORS;
            lcd.clear();
            break;
        case 2: // Reiniciar
            currentMenu = MENU_RESTART;
            menuSelection = 1; // Padrão para NÃO
            lcd.clear();
            break;
        case 3: // Voltar
            currentMenu = MENU_MAIN;
            menuSelection = 0;
            lcd.clear();
            break;
    }
}

/*
 * displayRawValues() - Exibe valores brutos do sensor
 */
void displayRawValues() {
    float voltage = readPhVoltage();
    int16_t adcRaw = ads.readADC_SingleEnded(0);
    
    lcd.setCursor(2, 0);
    lcd.print(F("VALORES BRUTOS"));
    
    lcd.setCursor(0, 1);
    lcd.print(F("Tensao: "));
    lcd.print(voltage, 3);
    lcd.print(F(" V"));
    
    lcd.setCursor(0, 2);
    lcd.print(F("ADC: "));
    lcd.print(adcRaw);
    
    lcd.setCursor(7, 3);
    lcd.print(F("Voltar"));
}

/*
 * checkSensors() - Verifica status de todos os sensores
 */
void checkSensors() {
    static bool checking = false;
    static unsigned long checkStart = 0;
    static uint8_t checkStep = 0;
    
    if (!checking) {
        checking = true;
        checkStart = millis();
        checkStep = 0;
        
        lcd.clear();
        lcd.setCursor(1, 0);
        lcd.print(F("TESTANDO SENSORES"));
        lcd.setCursor(1, 2);
        lcd.print(F("[                ]"));
    }
    
    // Animação da barra de progresso
    uint8_t progress = ((millis() - checkStart) * 16) / 3000;
    if (progress > 16) progress = 16;
    
    lcd.setCursor(2, 2);
    for (uint8_t i = 0; i < progress; i++) {
        lcd.print("=");
    }
    
    // Após 3 segundos, exibe resultados
    if (millis() - checkStart > 3000) {
        lcd.clear();
        lcd.setCursor(2, 0);
        lcd.print(F("STATUS SENSORES"));
        
        // Verifica sensor de pH
        float voltage = readPhVoltage();
        lcd.setCursor(0, 1);
        lcd.print(F("pH: "));
        if (voltage > 0.1 && voltage < 3.3) {
            lcd.print(F("OK"));
        } else {
            lcd.print(F("ERRO"));
        }
        
        // Verifica sensor de temperatura
        float temp = readTemperature();
        lcd.setCursor(0, 2);
        lcd.print(F("Temp: "));
        if (temp > -50 && temp < 100) {
            lcd.print(F("OK ("));
            lcd.print(temp, 1);
            lcd.print(F("C)"));
        } else {
            lcd.print(F("ERRO"));
        }
        
        lcd.setCursor(7, 3);
        lcd.print(F("Voltar"));
        
        checking = false;
    }
}

/*
 * restartSystem() - Tela de confirmação de reinicialização
 */
void restartSystem() {
    lcd.setCursor(1, 0);
    lcd.print(F("REINICIAR SISTEMA?"));
    
    lcd.setCursor(5, 2);
    if (menuSelection == 0) {
        lcd.print(F("> SIM"));
    } else {
        lcd.print(F("  SIM"));
    }
    
    lcd.setCursor(11, 2);
    if (menuSelection == 1) {
        lcd.print(F("> NAO"));
    } else {
        lcd.print(F("  NAO"));
    }
}

/*
 * resetSystem() - Reinicia o sistema via watchdog
 */
void resetSystem() {
    lcd.clear();
    lcd.setCursor(3, 1);
    lcd.print(F("REINICIANDO..."));
    delay(1000);
    
    // Força reset via watchdog
    wdt_enable(WDTO_15MS);
    while(1); // Espera watchdog resetar
}

// ===== FUNÇÕES DE PERSISTÊNCIA =====

/*
 * loadSettings() - Carrega configurações da EEPROM
 */
void loadSettings() {
    // Verifica se EEPROM tem dados válidos
    uint8_t magic;
    EEPROM.get(EEPROM_MAGIC, magic);
    
    if (magic != EEPROM_MAGIC_NUMBER) {
        // Primeira vez, inicializa EEPROM
        phIdeal = PH_DEFAULT;
        calibration.offset = 7.0;
        calibration.slope = 1.0;
        calibration.isValid = false;
        
        // Salva valores padrão
        EEPROM.put(EEPROM_PH_IDEAL, phIdeal);
        EEPROM.put(EEPROM_CAL_OFFSET, calibration.offset);
        EEPROM.put(EEPROM_CAL_SLOPE, calibration.slope);
        EEPROM.put(EEPROM_CALIBRATED, (uint8_t)0);
        EEPROM.put(EEPROM_MAGIC, EEPROM_MAGIC_NUMBER);
    } else {
        // Carrega valores salvos
        EEPROM.get(EEPROM_PH_IDEAL, phIdeal);
        EEPROM.get(EEPROM_CAL_OFFSET, calibration.offset);
        EEPROM.get(EEPROM_CAL_SLOPE, calibration.slope);
        
        uint8_t calFlag;
        EEPROM.get(EEPROM_CALIBRATED, calFlag);
        calibration.isValid = (calFlag == 1);
    }
    
    // Validação de sanidade
    if (phIdeal < PH_MIN || phIdeal > PH_MAX) {
        phIdeal = PH_DEFAULT;
    }
}

/*
 * FIM DO CÓDIGO
 * 
 * Este sistema foi desenvolvido para operar de forma contínua e confiável.
 * O watchdog garante que o sistema será reiniciado em caso de travamento.
 * Todas as configurações importantes são salvas na EEPROM.
 * 
 * Para adicionar novas funcionalidades:
 * 1. Adicione novos estados em MenuState
 * 2. Crie as funções de display correspondentes
 * 3. Adicione o processamento no switch do loop()
 * 4. Atualize as funções de navegação dos botões
 * 
 * Manutenção: 
 * - Verificar periodicamente a calibração do sensor de pH
 * - Limpar a sonda de pH regularmente
 * - Verificar conexões elétricas
 * - Substituir solução redutora de pH quando necessário
 */
