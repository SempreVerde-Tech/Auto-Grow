/***********************************************************************************************************************
 * Controlador de PH Automático para Cultivo
 *
 * Autor: Jules (Assistente de IA)
 * Versão: 1.7.5
 * Data: 2025-09-30
 *
 * Descrição:
 * Este código implementa um sistema de controle de pH automatizado para soluções de rega em cultivos.
 * Ele monitora continuamente o pH e a temperatura da solução, ajustando o pH para baixo quando
 * ele excede um valor ideal definido pelo usuário. O sistema é projetado para ser seguro,
 * estável e fácil de usar, com um menu interativo em uma tela LCD.
 *
 * Histórico de Versões:
 * v1.7.0:
 *  - Refatoração completa do controle da bomba para ser não-bloqueante, evitando resets do watchdog.
 *  - O tempo de espera (cooldown) da bomba agora é salvo na EEPROM, persistindo após reinicializações.
 *  - Corrigido bug no protetor de tela onde os blocos desapareciam após colidirem.
 *  - O monitoramento de pH agora continua a funcionar em segundo plano, mesmo com o protetor de tela ativo.
 *
 * Hardware Necessário:
 * - Arduino Nano
 * - Tela LCD I2C 20x4
 * - Módulo ADC ADS1115
 * - Sensor de Temperatura DS18B20
 * - Sonda de pH com módulo amplificador
 * - 3 Botões (MENU, UP, DOWN)
 * - Módulo MOSFET para acionar a bomba
 * - Bomba Peristáltica 5V
 * - LED indicador
 *
 * Bibliotecas Externas Necessárias (Instalar via Gerenciador de Bibliotecas do Arduino):
 * - LiquidCrystal_I2C by Frank de Brabander
 * - Adafruit ADS1X15 by Adafruit
 * - OneWire by Paul Stoffregen
 * - DallasTemperature by Miles Burton
 ***********************************************************************************************************************/

// =====================================================================================================================
// Inclusão de Bibliotecas
// =====================================================================================================================
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Adafruit_ADS1X15.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <EEPROM.h>
#include <avr/wdt.h>

// =====================================================================================================================
// Definição de Constantes (PINOS e CONFIGURAÇÕES)
// =====================================================================================================================
const int PIN_DS18B20 = 2;
const int PIN_BTN_MENU = 5;
const int PIN_BTN_DOWN = 4;
const int PIN_BTN_UP = 3;
const int PIN_MOSFET_PUMP = 6;
const int PIN_LED_LOW_PH = 7;

const int LCD_COLUMNS = 20;
const int LCD_ROWS = 4;
const int LCD_ADDRESS = 0x27;

const int ADS1115_ADDRESS = 0x48;
const int ADS_CHANNEL_PH = 0;

const int BUTTON_DEBOUNCE_DELAY = 50;

const float PH_IDEAL_DEFAULT = 7.0;
const float PH_CONTROL_THRESHOLD = 0.3;
const float PH_STABILITY_THRESHOLD = 0.1;
const unsigned long PUMP_DURATION_MS_DEFAULT = 1000;
const unsigned long PUMP_COOLDOWN_MS = 300000;

const int NUM_SAMPLES = 15;
const int NUM_SAMPLES_TO_DISCARD = 2;
const int CALIBRATION_MAX_ATTEMPTS = 5;
const unsigned long SAMPLING_INTERVAL_MS = 1000;

const unsigned long MENU_TIMEOUT_MS = 30000;
const unsigned long SCREENSAVER_TIMEOUT_MS = 30000;

const int EEPROM_ADDR_MAGIC = 0;
const int EEPROM_ADDR_CONFIG = sizeof(int);
const int EEPROM_MAGIC_VALUE = 12345;

// =====================================================================================================================
// Declaração de Objetos e Estruturas de Dados
// =====================================================================================================================
LiquidCrystal_I2C lcd(LCD_ADDRESS, LCD_COLUMNS, LCD_ROWS);
Adafruit_ADS1115 ads;
OneWire oneWire(PIN_DS18B20);
DallasTemperature tempSensor(&oneWire);

struct SystemConfig {
  float phIdeal;
  float calibOffsetVoltage;
  float calibSlope;
  bool isCalibrated2Points;
  unsigned long pumpDurationMs;
  unsigned long lastPumpActivationTime;
};
SystemConfig config;

enum SystemState {
  STATE_STARTUP,
  STATE_INITIAL_MENU,
  STATE_MONITORING,
  STATE_PUMPING,
  STATE_SCREENSAVER,
  STATE_MAIN_MENU,
  STATE_SET_PH_IDEAL,
  STATE_CALIBRATION_MENU,
  STATE_CALIBRATION_1_POINT_SELECT,
  STATE_CALIBRATION_2_POINTS_SELECT_1,
  STATE_CALIBRATION_2_POINTS_SELECT_2,
  STATE_CALIBRATE_WAIT_FOR_POINT,
  STATE_CALIBRATE_READING,
  STATE_CALIBRATION_ERROR,
  STATE_TECH_MENU,
  STATE_TECH_RAW_VALUES,
  STATE_TECH_CHECK_SENSORS,
  STATE_TECH_ACTIVATE_PUMP,
  STATE_TECH_SET_PUMP_TIMER,
  STATE_TECH_RESTART_CONFIRM
};
SystemState currentState = STATE_STARTUP;

enum PhStatus {
  PH_NORMAL,
  PH_LOW,
  PH_HIGH,
  PH_PUMPING
};
PhStatus currentPhStatus = PH_NORMAL;

float currentTemperature = 25.0;
float currentPhInst = 7.0;
float currentPhAvg = 7.0;

float phSamples[NUM_SAMPLES];
int sampleCount = 0;
unsigned long lastSampleTime = 0;

float stablePhHistory[3];
int stablePhHistoryIndex = 0;
unsigned long pumpStartTime = 0;

int btnMenuState, btnUpState, btnDownState;
int lastBtnMenuState = HIGH, lastBtnUpState = HIGH, lastBtnDownState = HIGH;
unsigned long lastDebounceTime = 0;
bool btnMenuPressed = false, btnUpPressed = false, btnDownPressed = false;

unsigned long lastActivityTime = 0;
float tempPhIdeal;
unsigned long tempPumpDurationMs;
int menuCursor = 0;
bool screenNeedsRedraw = true;

float calibrationSolutionValue1;
float calibrationSolutionValue2;
float tempVoltageReading1;
float tempVoltageReading2;
int calibrationPoint;
bool isTwoPointCalibration;

byte tetrisGrid[LCD_ROWS][LCD_COLUMNS];
int currentRow, currentCol;
unsigned long tetrisLastFallTime = 0;
bool tetrisAnimationMode = true;
const int TETRIS_FALL_DELAY = 200;
byte blockChar[8] = {B11111, B11111, B11111, B11111, B11111, B11111, B11111, B11111};

// =====================================================================================================================
// Declarações Antecipadas de Funções (Forward Declarations)
// =====================================================================================================================
void displayStartupMessage();
void displaySuccessMessage(const char* message);
void drawMonitoringLayout();
void updateMonitoringValues();
void handleInitialMenu();
void handleMonitoring();
void handlePumping();
void handleScreensaver();
void handleMainMenu();
void handleSetPhIdeal();
void handleCalibrationMenu();
void handleCalib1PointSelect();
void handleCalib2PointsSelect1();
void handleCalib2PointsSelect2();
void handleCalibrateWaitForPoint();
void handleCalibrateReading();
void handleCalibrationError();
void handleTechMenu();
void handleTechRawValues();
void handleTechCheckSensors();
void handleTechActivatePump();
void handleTechSetPumpTimer();
void handleTechRestartConfirm();
void checkPhAndControl();
void activatePump();
void displayInitialMenu();
void displayMainMenu();
void displaySetPhIdeal();
void displayCalibrationMenu();
void displayCalibSelect(const __FlashStringHelper* title, const __FlashStringHelper* subtitle, int pointNum);
void displayCalibInstruction(float solution);
void displayCalibrationError();
void displayTechMenu();
void drawTechRawValuesLayout();
void updateTechRawValues();
void displaySensorCheckScreen();
void checkSensors();
void displayRestartConfirm();
void displayTechSetPumpTimer();
float performCalibrationReading();
void sort(float a[], int size);
void resetTetrisGrid(bool mode);
void spawnNewPiece();
bool checkCollision(int r, int c);
void redrawFullGrid();
void runTetrisStep();

// =====================================================================================================================
// Função setup()
// =====================================================================================================================
void setup() {
  wdt_disable();
  wdt_enable(WDTO_8S);
  Serial.begin(9600);

  pinMode(PIN_BTN_MENU, INPUT_PULLUP);
  pinMode(PIN_BTN_UP, INPUT_PULLUP);
  pinMode(PIN_BTN_DOWN, INPUT_PULLUP);
  pinMode(PIN_MOSFET_PUMP, OUTPUT);
  pinMode(PIN_LED_LOW_PH, OUTPUT);
  digitalWrite(PIN_MOSFET_PUMP, LOW);
  digitalWrite(PIN_LED_LOW_PH, LOW);

  lcd.init();
  lcd.backlight();
  lcd.createChar(0, blockChar);
  displayStartupMessage();

  ads.begin();
  ads.setGain(GAIN_ONE);
  tempSensor.begin();

  loadConfigFromEEPROM();

  wdt_reset();
  delay(2000);

  currentState = STATE_INITIAL_MENU;
  screenNeedsRedraw = true;
  lastActivityTime = millis();
}

// =====================================================================================================================
// Função loop()
// =====================================================================================================================
void loop() {
  wdt_reset();
  readButtons();
  readSensors();

  if (currentState != STATE_PUMPING && sampleCount >= NUM_SAMPLES) {
    processPhSamples();
    checkPhAndControl();
    sampleCount = 0;
  }

  switch (currentState) {
    case STATE_STARTUP: break;
    case STATE_INITIAL_MENU: handleInitialMenu(); break;
    case STATE_MONITORING: handleMonitoring(); break;
    case STATE_PUMPING: handlePumping(); break;
    case STATE_SCREENSAVER: handleScreensaver(); break;
    case STATE_MAIN_MENU: handleMainMenu(); break;
    case STATE_SET_PH_IDEAL: handleSetPhIdeal(); break;
    case STATE_CALIBRATION_MENU: handleCalibrationMenu(); break;
    case STATE_CALIBRATION_1_POINT_SELECT: handleCalib1PointSelect(); break;
    case STATE_CALIBRATION_2_POINTS_SELECT_1: handleCalib2PointsSelect1(); break;
    case STATE_CALIBRATION_2_POINTS_SELECT_2: handleCalib2PointsSelect2(); break;
    case STATE_CALIBRATE_WAIT_FOR_POINT: handleCalibrateWaitForPoint(); break;
    case STATE_CALIBRATE_READING: handleCalibrateReading(); break;
    case STATE_CALIBRATION_ERROR: handleCalibrationError(); break;
    case STATE_TECH_MENU: handleTechMenu(); break;
    case STATE_TECH_RAW_VALUES: handleTechRawValues(); break;
    case STATE_TECH_CHECK_SENSORS: handleTechCheckSensors(); break;
    case STATE_TECH_ACTIVATE_PUMP: handleTechActivatePump(); break;
    case STATE_TECH_SET_PUMP_TIMER: handleTechSetPumpTimer(); break;
    case STATE_TECH_RESTART_CONFIRM: handleTechRestartConfirm(); break;
  }
  resetButtonFlags();
}

// =====================================================================================================================
// Funções de Leitura de Sensores e Botões
// =====================================================================================================================
void readButtons() {
  if ((millis() - lastDebounceTime) > BUTTON_DEBOUNCE_DELAY) {
    int readingMenu = digitalRead(PIN_BTN_MENU);
    if (readingMenu != lastBtnMenuState) {
      lastDebounceTime = millis();
      if (readingMenu == LOW) {
        btnMenuPressed = true;
        lastActivityTime = millis();
      }
    }
    lastBtnMenuState = readingMenu;

    int readingUp = digitalRead(PIN_BTN_UP);
    if (readingUp != lastBtnUpState) {
      lastDebounceTime = millis();
      if (readingUp == LOW) {
        btnUpPressed = true;
        lastActivityTime = millis();
      }
    }
    lastBtnUpState = readingUp;

    int readingDown = digitalRead(PIN_BTN_DOWN);
    if (readingDown != lastBtnDownState) {
      lastDebounceTime = millis();
      if (readingDown == LOW) {
        btnDownPressed = true;
        lastActivityTime = millis();
      }
    }
    lastBtnDownState = readingDown;
  }
}

void resetButtonFlags() {
  btnMenuPressed = false;
  btnUpPressed = false;
  btnDownPressed = false;
}

void readSensors() {
  if (millis() - lastSampleTime >= SAMPLING_INTERVAL_MS) {
    lastSampleTime = millis();
    tempSensor.requestTemperatures();
    float tempRead = tempSensor.getTempCByIndex(0);
    if (tempRead != DEVICE_DISCONNECTED_C && tempRead > 0 && tempRead < 100) {
      currentTemperature = tempRead;
    }
    int16_t adc_raw = ads.readADC_SingleEnded(ADS_CHANNEL_PH);
    float voltage = ads.computeVolts(adc_raw);
    currentPhInst = convertVoltageToPh(voltage, currentTemperature);
    if (sampleCount < NUM_SAMPLES) {
      phSamples[sampleCount] = currentPhInst;
      sampleCount++;
    }
  }
}

float convertVoltageToPh(float voltage, float temperature) {
  float tempFactor = (273.15 + temperature) / (273.15 + 25.0);
  float phValue = 7.0 + (voltage - config.calibOffsetVoltage) / (config.calibSlope * tempFactor);
  return phValue;
}

// =====================================================================================================================
// Funções de Gerenciamento de Estado (Handlers)
// =====================================================================================================================
void handleMonitoring() {
  if (screenNeedsRedraw) {
    drawMonitoringLayout();
    lastActivityTime = millis();
  }
  updateMonitoringValues();
  screenNeedsRedraw = false;

  if (btnMenuPressed) {
    currentState = STATE_MAIN_MENU;
    screenNeedsRedraw = true;
    menuCursor = 0;
    return;
  }

  if (millis() - lastActivityTime > SCREENSAVER_TIMEOUT_MS) {
      currentState = STATE_SCREENSAVER;
      screenNeedsRedraw = true;
  }
}

void handlePumping() {
  updateMonitoringValues();
  if (millis() - pumpStartTime >= config.pumpDurationMs) {
    digitalWrite(PIN_MOSFET_PUMP, LOW);
    for(int i=0; i<3; i++) stablePhHistory[i] = config.phIdeal;
    currentState = STATE_MONITORING;
    currentPhStatus = PH_HIGH;
    screenNeedsRedraw = true;
  }
}

void handleScreensaver() {
    if (btnMenuPressed || btnUpPressed || btnDownPressed) {
        currentState = STATE_MONITORING;
        screenNeedsRedraw = true;
        return;
    }
    if (screenNeedsRedraw) {
        resetTetrisGrid(tetrisAnimationMode);
        redrawFullGrid();
        spawnNewPiece();
        screenNeedsRedraw = false;
    }
    runTetrisStep();
}

void handleInitialMenu() {
    if (screenNeedsRedraw) {
        displayInitialMenu();
        screenNeedsRedraw = false;
    }
    if (btnUpPressed) {
        menuCursor = (menuCursor > 0) ? menuCursor - 1 : 2;
        screenNeedsRedraw = true;
    }
    if (btnDownPressed) {
        menuCursor = (menuCursor < 2) ? menuCursor + 1 : 0;
        screenNeedsRedraw = true;
    }
    if (btnMenuPressed) {
        switch (menuCursor) {
            case 0: currentState = STATE_MONITORING; break;
            case 1: currentState = STATE_CALIBRATION_MENU; menuCursor = 0; break;
            case 2: currentState = STATE_TECH_MENU; menuCursor = 0; break;
        }
        screenNeedsRedraw = true;
    }
}

void handleMainMenu() {
  if (screenNeedsRedraw) {
    displayMainMenu();
    screenNeedsRedraw = false;
  }
  if (millis() - lastActivityTime > MENU_TIMEOUT_MS) {
    currentState = STATE_MONITORING;
    screenNeedsRedraw = true;
    return;
  }
  if (btnUpPressed) {
    menuCursor = (menuCursor > 0) ? menuCursor - 1 : 3;
    screenNeedsRedraw = true;
  }
  if (btnDownPressed) {
    menuCursor = (menuCursor < 3) ? menuCursor + 1 : 0;
    screenNeedsRedraw = true;
  }
  if (btnMenuPressed) {
    switch (menuCursor) {
      case 0: currentState = STATE_SET_PH_IDEAL; tempPhIdeal = config.phIdeal; break;
      case 1: currentState = STATE_CALIBRATION_MENU; menuCursor = 0; break;
      case 2: currentState = STATE_TECH_MENU; menuCursor = 0; break;
      case 3: currentState = STATE_MONITORING; break;
    }
    screenNeedsRedraw = true;
  }
}

void handleSetPhIdeal() {
  if (screenNeedsRedraw) {
    displaySetPhIdeal();
    screenNeedsRedraw = false;
  }
  if (millis() - lastActivityTime > MENU_TIMEOUT_MS) {
    currentState = STATE_MONITORING;
    screenNeedsRedraw = true;
    return;
  }
  if (btnUpPressed) {
    tempPhIdeal += 0.1;
    screenNeedsRedraw = true;
  }
  if (btnDownPressed) {
    tempPhIdeal -= 0.1;
    screenNeedsRedraw = true;
  }
  if (tempPhIdeal > 13.0) tempPhIdeal = 13.0;
  if (tempPhIdeal < 1.0) tempPhIdeal = 1.0;
  if (btnMenuPressed) {
    config.phIdeal = tempPhIdeal;
    saveConfigToEEPROM();
    displaySuccessMessage("  VALOR SALVO!  ");
    currentState = STATE_MONITORING;
    screenNeedsRedraw = true;
  }
}

void handleCalibrationMenu() {
    if (screenNeedsRedraw) {
        displayCalibrationMenu();
        screenNeedsRedraw = false;
    }
    if (millis() - lastActivityTime > MENU_TIMEOUT_MS) {
        currentState = STATE_MONITORING;
        screenNeedsRedraw = true;
        return;
    }
    if (btnUpPressed) {
        menuCursor = (menuCursor > 0) ? menuCursor - 1 : 2;
        screenNeedsRedraw = true;
    }
    if (btnDownPressed) {
        menuCursor = (menuCursor < 2) ? menuCursor + 1 : 0;
        screenNeedsRedraw = true;
    }
    if (btnMenuPressed) {
        switch (menuCursor) {
            case 0: currentState = STATE_CALIBRATION_1_POINT_SELECT; menuCursor = 0; break;
            case 1: currentState = STATE_CALIBRATION_2_POINTS_SELECT_1; menuCursor = 0; break;
            case 2: currentState = STATE_MAIN_MENU; menuCursor = 1; break;
        }
        screenNeedsRedraw = true;
    }
}

void handleCalib1PointSelect() {
    if (screenNeedsRedraw) {
        displayCalibSelect(F("CALIBRAR 1 PONTO"), F("Selecione SOLUCAO:"), 0);
        screenNeedsRedraw = false;
    }
    if (millis() - lastActivityTime > MENU_TIMEOUT_MS) {
        currentState = STATE_CALIBRATION_MENU;
        screenNeedsRedraw = true;
        menuCursor = 0;
        return;
    }
    if (btnUpPressed) {
        menuCursor = (menuCursor > 0) ? menuCursor - 1 : 3;
        screenNeedsRedraw = true;
    }
    if (btnDownPressed) {
        menuCursor = (menuCursor < 3) ? menuCursor + 1 : 0;
        screenNeedsRedraw = true;
    }
    if (btnMenuPressed) {
        if (menuCursor == 3) {
            currentState = STATE_CALIBRATION_MENU;
            menuCursor = 0;
        } else {
            float solutions[] = {4.01, 7.01, 10.01};
            calibrationSolutionValue1 = solutions[menuCursor];
            isTwoPointCalibration = false;
            calibrationPoint = 1;
            currentState = STATE_CALIBRATE_WAIT_FOR_POINT;
        }
        screenNeedsRedraw = true;
    }
}

void handleCalib2PointsSelect1() {
    if (screenNeedsRedraw) {
        displayCalibSelect(F("CALIBRAR 2 PONTOS"), F("Selecione PONTO 1:"), 0);
        screenNeedsRedraw = false;
    }
    if (millis() - lastActivityTime > MENU_TIMEOUT_MS) {
        currentState = STATE_CALIBRATION_MENU;
        screenNeedsRedraw = true;
        menuCursor = 0;
        return;
    }
    if (btnUpPressed) {
        menuCursor = (menuCursor > 0) ? menuCursor - 1 : 3;
        screenNeedsRedraw = true;
    }
    if (btnDownPressed) {
        menuCursor = (menuCursor < 3) ? menuCursor + 1 : 0;
        screenNeedsRedraw = true;
    }
    if (btnMenuPressed) {
        if (menuCursor == 3) {
            currentState = STATE_CALIBRATION_MENU;
            menuCursor = 0;
        } else {
            float solutions[] = {4.01, 7.01, 10.01};
            calibrationSolutionValue1 = solutions[menuCursor];
            currentState = STATE_CALIBRATION_2_POINTS_SELECT_2;
            menuCursor = 0;
        }
        screenNeedsRedraw = true;
    }
}

void handleCalib2PointsSelect2() {
    if (screenNeedsRedraw) {
        displayCalibSelect(F("CALIBRAR 2 PONTOS"), F("Selecione PONTO 2:"), 1);
        screenNeedsRedraw = false;
    }
     if (millis() - lastActivityTime > MENU_TIMEOUT_MS) {
        currentState = STATE_CALIBRATION_MENU;
        screenNeedsRedraw = true;
        menuCursor = 0;
        return;
    }
    if (btnUpPressed) {
        menuCursor = (menuCursor > 0) ? menuCursor - 1 : 2;
        screenNeedsRedraw = true;
    }
    if (btnDownPressed) {
        menuCursor = (menuCursor < 2) ? menuCursor + 1 : 0;
        screenNeedsRedraw = true;
    }
    if (btnMenuPressed) {
        if (menuCursor == 2) {
            currentState = STATE_CALIBRATION_2_POINTS_SELECT_1;
            menuCursor = 0;
        } else {
            float solutions[] = {4.01, 7.01, 10.01};
            int choiceIndex = 0;
            for (int i = 0; i < 3; i++) {
                if (abs(solutions[i] - calibrationSolutionValue1) > 0.1) {
                    if (choiceIndex == menuCursor) {
                        calibrationSolutionValue2 = solutions[i];
                        break;
                    }
                    choiceIndex++;
                }
            }
            isTwoPointCalibration = true;
            calibrationPoint = 1;
            currentState = STATE_CALIBRATE_WAIT_FOR_POINT;
        }
        screenNeedsRedraw = true;
    }
}

void handleCalibrateWaitForPoint() {
    if (screenNeedsRedraw) {
        float solutionValue = (calibrationPoint == 1) ? calibrationSolutionValue1 : calibrationSolutionValue2;
        displayCalibInstruction(solutionValue);
        screenNeedsRedraw = false;
    }
    if (btnMenuPressed) {
        currentState = STATE_CALIBRATE_READING;
        screenNeedsRedraw = true;
    }
}

void handleCalibrateReading() {
    float voltageReading = performCalibrationReading();
    if (voltageReading < 0) {
        currentState = STATE_CALIBRATION_ERROR;
        screenNeedsRedraw = true;
        return;
    }
    if (calibrationPoint == 1) {
        tempVoltageReading1 = voltageReading;
        if (isTwoPointCalibration) {
            calibrationPoint = 2;
            currentState = STATE_CALIBRATE_WAIT_FOR_POINT;
        } else {
            config.calibOffsetVoltage = tempVoltageReading1 + (config.calibSlope * (7.0 - calibrationSolutionValue1));
            config.isCalibrated2Points = false;
            saveConfigToEEPROM();
            displaySuccessMessage("Calibragem OK!");
            currentState = STATE_MONITORING;
        }
    } else {
        tempVoltageReading2 = voltageReading;
        if (abs(tempVoltageReading1 - tempVoltageReading2) > 0.01 && abs(calibrationSolutionValue1 - calibrationSolutionValue2) > 1) {
            config.calibSlope = (tempVoltageReading1 - tempVoltageReading2) / (calibrationSolutionValue1 - calibrationSolutionValue2);
            config.calibOffsetVoltage = tempVoltageReading1 + (config.calibSlope * (7.0 - calibrationSolutionValue1));
            config.isCalibrated2Points = true;
            saveConfigToEEPROM();
            displaySuccessMessage("Calibragem OK!");
            currentState = STATE_MONITORING;
        } else {
            currentState = STATE_CALIBRATION_ERROR;
        }
    }
    screenNeedsRedraw = true;
}

void handleCalibrationError() {
    if (screenNeedsRedraw) {
        displayCalibrationError();
        screenNeedsRedraw = false;
    }
    if (btnUpPressed || btnDownPressed) {
        menuCursor = !menuCursor;
        screenNeedsRedraw = true;
    }
    if (btnMenuPressed) {
        if (menuCursor == 0) {
            currentState = STATE_CALIBRATION_MENU;
            menuCursor = 0;
        } else {
            currentState = STATE_MAIN_MENU;
            menuCursor = 1;
        }
        screenNeedsRedraw = true;
    }
}

void handleTechMenu() {
    if (screenNeedsRedraw) {
        displayTechMenu();
        screenNeedsRedraw = false;
    }
    if (millis() - lastActivityTime > MENU_TIMEOUT_MS) {
        currentState = STATE_MONITORING;
        screenNeedsRedraw = true;
        return;
    }
    if (btnUpPressed) {
        menuCursor = (menuCursor > 0) ? menuCursor - 1 : 5;
        screenNeedsRedraw = true;
    }
    if (btnDownPressed) {
        menuCursor = (menuCursor < 5) ? menuCursor + 1 : 0;
        screenNeedsRedraw = true;
    }
    if (btnMenuPressed) {
        switch (menuCursor) {
            case 0: currentState = STATE_TECH_RAW_VALUES; break;
            case 1: currentState = STATE_TECH_CHECK_SENSORS; break;
            case 2: currentState = STATE_TECH_ACTIVATE_PUMP; break;
            case 3: currentState = STATE_TECH_SET_PUMP_TIMER; tempPumpDurationMs = config.pumpDurationMs; break;
            case 4: currentState = STATE_TECH_RESTART_CONFIRM; menuCursor = 1; break;
            case 5: currentState = STATE_MAIN_MENU; menuCursor = 2; break;
        }
        screenNeedsRedraw = true;
    }
}

void handleTechRawValues() {
    if (screenNeedsRedraw) {
        drawTechRawValuesLayout();
        screenNeedsRedraw = false;
    }
    updateTechRawValues();
    if (btnMenuPressed) {
        currentState = STATE_TECH_MENU;
        screenNeedsRedraw = true;
        menuCursor = 0;
    }
}

void handleTechCheckSensors() {
    if (screenNeedsRedraw) {
        displaySensorCheckScreen();
        checkSensors();
        screenNeedsRedraw = false;
    }
    if (btnMenuPressed) {
        currentState = STATE_TECH_MENU;
        screenNeedsRedraw = true;
        menuCursor = 1;
    }
}

void handleTechActivatePump() {
    if (screenNeedsRedraw) {
        lcd.clear();
        lcd.setCursor(0, 0);
        lcd.print(F("  ATIVACAO MANUAL   "));
        lcd.setCursor(0, 1);
        lcd.print(F("Mantenha UP para"));
        lcd.setCursor(0, 2);
        lcd.print(F("ligar a bomba."));
        lcd.setCursor(0, 3);
        lcd.print(F("MENU para Voltar"));
        screenNeedsRedraw = false;
    }
    if (digitalRead(PIN_BTN_UP) == LOW) {
        digitalWrite(PIN_MOSFET_PUMP, HIGH);
    } else {
        digitalWrite(PIN_MOSFET_PUMP, LOW);
    }
    if (btnMenuPressed) {
        digitalWrite(PIN_MOSFET_PUMP, LOW);
        currentState = STATE_TECH_MENU;
        menuCursor = 2;
        screenNeedsRedraw = true;
    }
}

void handleTechSetPumpTimer() {
  if (screenNeedsRedraw) {
    displayTechSetPumpTimer();
    screenNeedsRedraw = false;
  }
  if (millis() - lastActivityTime > MENU_TIMEOUT_MS) {
    currentState = STATE_TECH_MENU;
    menuCursor = 3;
    screenNeedsRedraw = true;
    return;
  }
  if (btnUpPressed) {
    tempPumpDurationMs += 500;
    screenNeedsRedraw = true;
  }
  if (btnDownPressed) {
    tempPumpDurationMs -= 500;
    screenNeedsRedraw = true;
  }
  if (tempPumpDurationMs < 500 || tempPumpDurationMs > 10000) {
    tempPumpDurationMs = 500;
  }
  if (btnMenuPressed) {
    config.pumpDurationMs = tempPumpDurationMs;
    saveConfigToEEPROM();
    displaySuccessMessage("  TIMER SALVO!  ");
    currentState = STATE_TECH_MENU;
    menuCursor = 3;
    screenNeedsRedraw = true;
  }
}

void handleTechRestartConfirm() {
    if (screenNeedsRedraw) {
        displayRestartConfirm();
        screenNeedsRedraw = false;
    }
    if (btnUpPressed || btnDownPressed) {
        menuCursor = !menuCursor;
        screenNeedsRedraw = true;
    }
    if (btnMenuPressed) {
        if (menuCursor == 0) {
            lcd.clear();
            lcd.setCursor(0, 1);
            lcd.print(F("  REINICIANDO...  "));
            delay(2000);
            while (true);
        } else {
            currentState = STATE_TECH_MENU;
            screenNeedsRedraw = true;
            menuCursor = 4;
        }
    }
}

// =====================================================================================================================
// Funções de Lógica de Controle
// =====================================================================================================================
void processPhSamples() {
  sort(phSamples, NUM_SAMPLES);
  float sum = 0;
  for (int i = NUM_SAMPLES_TO_DISCARD; i < NUM_SAMPLES - NUM_SAMPLES_TO_DISCARD; i++) {
    sum += phSamples[i];
  }
  int numSamplesForAvg = NUM_SAMPLES - (2 * NUM_SAMPLES_TO_DISCARD);
  currentPhAvg = sum / numSamplesForAvg;
  stablePhHistory[stablePhHistoryIndex] = currentPhAvg;
  stablePhHistoryIndex = (stablePhHistoryIndex + 1) % 3;
}

void checkPhAndControl() {
  bool isPumpOnCooldown = (millis() - config.lastPumpActivationTime) < PUMP_COOLDOWN_MS;
  if (currentState == STATE_PUMPING) {
    return;
  }
  float maxDiff = 0;
  float diff1 = abs(stablePhHistory[0] - stablePhHistory[1]);
  float diff2 = abs(stablePhHistory[1] - stablePhHistory[2]);
  float diff3 = abs(stablePhHistory[0] - stablePhHistory[2]);
  maxDiff = max(diff1, max(diff2, diff3));

  if (maxDiff <= PH_STABILITY_THRESHOLD) {
    if (currentPhAvg > config.phIdeal + PH_CONTROL_THRESHOLD) {
      currentPhStatus = PH_HIGH;
      digitalWrite(PIN_LED_LOW_PH, LOW);
      if (!isPumpOnCooldown) {
        activatePump();
      }
    } else if (currentPhAvg < config.phIdeal - PH_CONTROL_THRESHOLD) {
      currentPhStatus = PH_LOW;
      digitalWrite(PIN_LED_LOW_PH, HIGH);
    } else {
      currentPhStatus = PH_NORMAL;
      digitalWrite(PIN_LED_LOW_PH, LOW);
    }
  }
}

void activatePump() {
  if (currentState == STATE_SCREENSAVER) {
    currentState = STATE_MONITORING;
  }
  config.lastPumpActivationTime = millis();
  saveConfigToEEPROM();
  digitalWrite(PIN_MOSFET_PUMP, HIGH);
  pumpStartTime = millis();
  currentState = STATE_PUMPING;
  currentPhStatus = PH_PUMPING;
  screenNeedsRedraw = true;
}

// =====================================================================================================================
// Funções do Screensaver (Animação de Blocos)
// =====================================================================================================================
void resetTetrisGrid(bool mode) {
    for (int r = 0; r < LCD_ROWS; r++) {
        for (int c = 0; c < LCD_COLUMNS; c++) {
            tetrisGrid[r][c] = mode ? 0 : 1;
        }
    }
}

void spawnNewPiece() {
    currentRow = 0;
    currentCol = random(LCD_COLUMNS);
}

bool checkCollision(int r, int c) {
    if (r >= LCD_ROWS) {
        return true;
    }
    if (r >= 0 && c >= 0 && r < LCD_ROWS && c < LCD_COLUMNS && tetrisGrid[r][c] == (tetrisAnimationMode ? 1 : 0)) {
        return true;
    }
    return false;
}

void redrawFullGrid() {
    lcd.clear();
    for (int r = 0; r < LCD_ROWS; r++) {
        for (int c = 0; c < LCD_COLUMNS; c++) {
            if (tetrisGrid[r][c]) {
                lcd.setCursor(c, r);
                lcd.write((byte)0);
            }
        }
    }
}

void runTetrisStep() {
    if (millis() - tetrisLastFallTime > TETRIS_FALL_DELAY) {
        tetrisLastFallTime = millis();

        // Apaga a peça da posição antiga
        if (currentRow >= 0 && currentRow < LCD_ROWS && currentCol >= 0 && currentCol < LCD_COLUMNS) {
            lcd.setCursor(currentCol, currentRow);
            // Redesenha o que estava no grid naquela posição (geralmente vazio)
            if (tetrisGrid[currentRow][currentCol]) {
                lcd.write((byte)0);
            } else {
                lcd.print(' ');
            }
        }

        // Move a peça para a nova posição
        if (!checkCollision(currentRow + 1, currentCol)) {
            currentRow++;
        } else {
            // Trava a peça no grid
            if (currentRow >= 0 && currentRow < LCD_ROWS && currentCol >= 0 && currentCol < LCD_COLUMNS) {
                tetrisGrid[currentRow][currentCol] = 1;
            }

            // Verifica se a tela está cheia para inverter a animação
            bool isScreenFull = true;
            for(int r = 0; r < LCD_ROWS; r++) {
                for(int c = 0; c < LCD_COLUMNS; c++) {
                    if (tetrisGrid[r][c] == 0) {
                        isScreenFull = false;
                        break;
                    }
                }
                if (!isScreenFull) break;
            }

            if (isScreenFull) {
                delay(1000); // Pausa para o usuário ver a tela cheia
                resetTetrisGrid(false); // Limpa o grid lógico
                redrawFullGrid(); // Limpa a tela visualmente
            }

            spawnNewPiece();

            // Se a nova peça já colide, a tela está cheia, então limpa tudo
            if(checkCollision(currentRow, currentCol)){
                resetTetrisGrid(false);
                redrawFullGrid();
            }
        }

        // Desenha a peça na nova posição
        if (currentRow >= 0 && currentRow < LCD_ROWS && currentCol >= 0 && currentCol < LCD_COLUMNS) {
             lcd.setCursor(currentCol, currentRow);
             lcd.write((byte)0);
        }
    }
}

// =====================================================================================================================
// Funções de Calibragem
// =====================================================================================================================
float performCalibrationReading() {
    float lastAvg = 0, currentAvg = 0;
    for (int attempt = 0; attempt < CALIBRATION_MAX_ATTEMPTS; attempt++) {
        lcd.clear();
        lcd.setCursor(0, 1);
        lcd.print(F("Lendo... Tentativa "));
        lcd.print(attempt + 1);
        float samples[NUM_SAMPLES];
        for (int i = 0; i < NUM_SAMPLES; i++) {
            samples[i] = ads.computeVolts(ads.readADC_SingleEnded(ADS_CHANNEL_PH));
            delay(SAMPLING_INTERVAL_MS);
            wdt_reset();
        }
        sort(samples, NUM_SAMPLES);
        float sum = 0;
        for (int i = NUM_SAMPLES_TO_DISCARD; i < NUM_SAMPLES - NUM_SAMPLES_TO_DISCARD; i++) {
            sum += samples[i];
        }
        currentAvg = sum / (NUM_SAMPLES - 2 * NUM_SAMPLES_TO_DISCARD);
        if (attempt > 0 && abs(currentAvg - lastAvg) <= 0.001) {
            return currentAvg;
        }
        lastAvg = currentAvg;
    }
    return -1.0;
}

// =====================================================================================================================
// Funções de Exibição na Tela (Display)
// =====================================================================================================================
void displayStartupMessage() {
  lcd.clear();
  lcd.setCursor(0, 1);
  lcd.print(F(" Controlador de pH"));
  lcd.setCursor(0, 2);
  lcd.print(F("  Inicializando..."));
}

void drawMonitoringLayout() {
  lcd.clear();
  lcd.setCursor(0, 1);
  lcd.print(F("PH ATUAL: "));
  lcd.setCursor(0, 2);
  lcd.print(F("PH INST:  "));
  lcd.setCursor(0, 3);
  lcd.print(F("T:"));
  lcd.setCursor(6, 3);
  lcd.print((char)223);
  lcd.print(F("C  Ideal:"));
}

void updateMonitoringValues() {
  static int spinnerPos = 0;
  const char spinner[] = "|/-\\";
  static PhStatus lastPhStatus = PH_NORMAL;
  if (screenNeedsRedraw || currentPhStatus != lastPhStatus) {
    lcd.setCursor(0, 0);
    switch (currentPhStatus) {
      case PH_LOW: lcd.print(F(" PH ATUAL < IDEAL   ")); break;
      case PH_HIGH: lcd.print(F(" AJUSTANDO PH(AGUAR)")); break;
      case PH_PUMPING: lcd.print(F(" BOMBEANDO...       ")); break;
      case PH_NORMAL: default: lcd.print(F(" MONITORANDO        ")); break;
    }
  }
  lcd.setCursor(19, 0);
  lcd.print(spinner[spinnerPos]);
  spinnerPos = (spinnerPos + 1) % 4;
  lastPhStatus = currentPhStatus;
  lcd.setCursor(10, 1);
  lcd.print(currentPhAvg, 2);
  lcd.print(F("   "));
  lcd.setCursor(10, 2);
  lcd.print(currentPhInst, 2);
  lcd.print(F("   "));
  lcd.setCursor(2, 3);
  lcd.print(currentTemperature, 1);
  lcd.print(" ");
  lcd.setCursor(17, 3);
  lcd.print(config.phIdeal, 1);
  lcd.print(" ");
}

void displayInitialMenu() {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F("    MENU INICIAL    "));
    const char* options[] = {"Monitorar", "Calibrar Sonda", "Menu Tecnico"};
    for (int i = 0; i < 3; i++) {
        lcd.setCursor(1, i + 1);
        lcd.print(menuCursor == i ? ">" : " ");
        lcd.print(options[i]);
    }
}

void displayMainMenu() {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F("   MENU PRINCIPAL   "));
    const char* options[] = {"Definir PH Ideal", "Calibrar Sonda", "Menu Tecnico", "Voltar"};
    const int numOptions = 4;
    int displayOffset = 0;
    if (menuCursor > 2) {
        displayOffset = menuCursor - 2;
    }
    for (int i = 0; i < 3; i++) {
        int optionIndex = i + displayOffset;
        if (optionIndex < numOptions) {
            lcd.setCursor(1, i + 1);
            lcd.print(menuCursor == optionIndex ? ">" : " ");
            lcd.print(options[optionIndex]);
        }
    }
}

void displaySetPhIdeal() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(F("  DEFINIR PH IDEAL  "));
  lcd.setCursor(0, 2);
  lcd.print(F("   PH Ideal: "));
  lcd.print(tempPhIdeal, 1);
  lcd.setCursor(0, 3);
  lcd.print(F("Press. MENU p/salvar"));
}

void displayCalibrationMenu() {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F("  CALIBRAR SONDA  "));
    const char* options[] = {"1 Ponto", "2 Pontos", "Voltar"};
    for (int i = 0; i < 3; i++) {
        lcd.setCursor(1, i + 1);
        lcd.print(menuCursor == i ? ">" : " ");
        lcd.print(options[i]);
    }
}

void displayCalibSelect(const __FlashStringHelper* title, const __FlashStringHelper* subtitle, int pointNum) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(title);
    lcd.setCursor(0, 1);
    lcd.print(subtitle);
    const int numVisibleOptions = 2;
    const char* options[4];
    int numOptions;
    if (pointNum == 0) {
        options[0] = "Solucao 4.01";
        options[1] = "Solucao 7.01";
        options[2] = "Solucao 10.01";
        options[3] = "Voltar";
        numOptions = 4;
    } else {
        numOptions = 0;
        float allSolutions[] = {4.01, 7.01, 10.01};
        const char* allOptions[] = {"Solucao 4.01", "Solucao 7.01", "Solucao 10.01"};
        for(int i=0; i<3; i++){
            if(abs(allSolutions[i] - calibrationSolutionValue1) > 0.1){
                options[numOptions++] = allOptions[i];
            }
        }
        options[numOptions++] = "Voltar";
    }
    int displayOffset = 0;
    if (menuCursor >= numVisibleOptions) {
        displayOffset = menuCursor - (numVisibleOptions - 1);
    }
    for (int i = 0; i < numVisibleOptions; i++) {
        int optionIndex = i + displayOffset;
        lcd.setCursor(0, i + 2);
        lcd.print("                    ");
        if (optionIndex < numOptions) {
            lcd.setCursor(1, i + 2);
            lcd.print(menuCursor == optionIndex ? ">" : " ");
            lcd.print(options[optionIndex]);
        }
    }
}

void displayCalibInstruction(float solution) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F("Insira a sonda na"));
    lcd.setCursor(0, 1);
    lcd.print(F("solucao de pH "));
    lcd.print(solution, 2);
    lcd.setCursor(0, 3);
    lcd.print(F("Press. MENU quando"));
}

void displayCalibrationError() {
    lcd.clear();
    lcd.setCursor(0, 1);
    lcd.print(F(" ERRO DE CALIBRAGEM "));
    lcd.setCursor(1, 2);
    lcd.print(menuCursor == 0 ? ">" : " ");
    lcd.print("Tentar Novamente");
    lcd.setCursor(1, 3);
    lcd.print(menuCursor == 1 ? ">" : " ");
    lcd.print("Voltar");
}

void displayTechMenu() {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F("    MENU TECNICO    "));
    const char* options[] = {"Valores Brutos", "Checar Sensores", "Ativar Bomba", "Timer Bomba", "Reiniciar", "Voltar"};
    const int numOptions = 6;
    int displayOffset = 0;
    if (menuCursor > 2) {
        displayOffset = menuCursor - 2;
    }
    for (int i = 0; i < 3; i++) {
        int optionIndex = i + displayOffset;
        if (optionIndex < numOptions) {
            lcd.setCursor(1, i + 1);
            lcd.print(menuCursor == optionIndex ? ">" : " ");
            lcd.print(options[optionIndex]);
        }
    }
}

void drawTechRawValuesLayout() {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F("   VALORES BRUTOS   "));
    lcd.setCursor(0, 1);
    lcd.print(F("pH(V): "));
    lcd.setCursor(0, 2);
    lcd.print(F("Temp(C): "));
    lcd.setCursor(0, 3);
    lcd.print(F("MENU para Voltar"));
}

void updateTechRawValues() {
    lcd.setCursor(7, 1);
    lcd.print(ads.computeVolts(ads.readADC_SingleEnded(ADS_CHANNEL_PH)), 4);
    lcd.setCursor(9, 2);
    lcd.print(currentTemperature, 2);
}

void displaySensorCheckScreen() {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F("  CHECANDO SENSORES "));
    lcd.setCursor(0, 2);
    lcd.print(F("      Aguarde...    "));
}

void displayRestartConfirm() {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F(" REINICIAR SISTEMA? "));
    lcd.setCursor(5, 2);
    lcd.print(menuCursor == 0 ? ">SIM" : " SIM");
    lcd.setCursor(12, 2);
    lcd.print(menuCursor == 1 ? ">NAO" : " NAO");
}

void displayTechSetPumpTimer() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(F(" AJUSTAR TIMER BOMBA"));
  lcd.setCursor(0, 2);
  lcd.print(F("  Tempo: "));
  lcd.print(tempPumpDurationMs / 1000.0, 1);
  lcd.print(F("s"));
  lcd.setCursor(0, 3);
  lcd.print(F("Press. MENU p/salvar"));
}

void displaySuccessMessage(const char* message) {
    lcd.clear();
    lcd.setCursor(0, 1);
    lcd.print(message);
    delay(2000);
}

// =====================================================================================================================
// Funções Utilitárias
// =====================================================================================================================
void saveConfigToEEPROM() {
  EEPROM.put(EEPROM_ADDR_MAGIC, EEPROM_MAGIC_VALUE);
  EEPROM.put(EEPROM_ADDR_CONFIG, config);
}

void loadConfigFromEEPROM() {
  int magic;
  EEPROM.get(EEPROM_ADDR_MAGIC, magic);
  if (magic == EEPROM_MAGIC_VALUE) {
    EEPROM.get(EEPROM_ADDR_CONFIG, config);
    if (config.pumpDurationMs == 0 || config.pumpDurationMs > 60000) {
        config.pumpDurationMs = PUMP_DURATION_MS_DEFAULT;
    }
    if (config.lastPumpActivationTime == 0xFFFFFFFF) {
        config.lastPumpActivationTime = 0;
    }
  } else {
    config.phIdeal = PH_IDEAL_DEFAULT;
    config.calibOffsetVoltage = 0.0;
    config.calibSlope = -0.05916;
    config.isCalibrated2Points = false;
    config.pumpDurationMs = PUMP_DURATION_MS_DEFAULT;
    config.lastPumpActivationTime = 0;
    saveConfigToEEPROM();
  }
}

void sort(float a[], int size) {
  for (int i = 0; i < (size - 1); i++) {
    for (int o = 0; o < (size - (i + 1)); o++) {
      if (a[o] > a[o + 1]) {
        float t = a[o];
        a[o] = a[o + 1];
        a[o + 1] = t;
      }
    }
  }
}

void checkSensors() {
    delay(1500);
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F(" STATUS DOS SENSORES"));
    lcd.setCursor(0, 1);
    lcd.print(F("LCD I2C: OK"));
    Wire.beginTransmission(ADS1115_ADDRESS);
    byte error = Wire.endTransmission();
    lcd.setCursor(0, 2);
    lcd.print(F("ADS1115: "));
    lcd.print(error == 0 ? "OK" : "FALHA");
    lcd.setCursor(0, 3);
    lcd.print(F("DS18B20: "));
    tempSensor.requestTemperatures();
    lcd.print(tempSensor.getTempCByIndex(0) != DEVICE_DISCONNECTED_C ? "OK" : "FALHA");
}
