/*
  Sistema de Controle de pH Automático para Arduino
  Autor: Jules (baseado no código de "Chai" e aprimorado com as solicitações do usuário)
  Versão: Final e Corrigida com Watchdog
  Descrição: Este firmware controla o pH de uma solução, com compensação de temperatura,
  calibração de 1 e 2 pontos, e uma interface de usuário não-bloqueante no LCD.
  Inclui lógica robusta para medição de pH, é configurável para botões físicos ou touch,
  e possui um watchdog timer para máxima estabilidade a longo prazo.
*/

#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <EEPROM.h>
#include <avr/wdt.h> // Biblioteca para o Watchdog Timer

LiquidCrystal_I2C lcd(0x27, 20, 4);

#define ONE_WIRE_BUS 2
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);

const int pHPin = A0;
const int upButton = 3;
const int downButton = 4;
const int menuButton = 5;
const int pumpPin = 6;
const int ledPin = 7;

const float ADC_REF = 5.0;
const float ADC_MAX = 1023.0;
const float KELVIN_25 = 298.15;
const int PH_READING_COUNT = 10;
const unsigned long pumpDuration = 10000;
const unsigned long waitAfterPump = 300000;
const unsigned long timeout = 30000;

const bool BUTTON_LOGIC_INVERTED = true;

float pHValue;
float temperature;
float pHIdeal = 6.0;
float pHOffset = 0.0;
float pHSlope = 1.0;

const float calibpH4 = 4.01;
const float calibpH7 = 7.01;
const float calibpH10 = 10.01;

enum State {
  MAIN, MENU, ADJUST_PH, CALIBRATE, CALIBRATE_MODE,
  CALIBRATE_ONE_POINT, CALIBRATE_TWO_POINT_FIRST, CALIBRATE_TWO_POINT_SECOND,
  INITIAL_CALIBRATION_PROMPT
};
State currentState = MAIN;

bool upPressed = false;
bool downPressed = false;
bool menuPressed = false;
unsigned long lastButtonPress = 0;
float pHReadings[PH_READING_COUNT];
int readingIndex = 0;
unsigned long lastPumpTime = 0;
unsigned long lastPhReadTime = 0;
unsigned long lastTempReadTime = 0;
bool pumpActive = false;
bool waitingAfterPump = false;
bool pHBelowIdeal = false;

#define FIRST_RUN_FLAG_ADDR 1023
#define PH_IDEAL_ADDR 0
#define PH_OFFSET_ADDR 4
#define PH_SLOPE_ADDR 8

int menuIndex = 0;
int calibMenuIndex = 0;
int calibSolutionIndex = 0;
float firstCalibValue = 0;
int selectedCalibPoint = 0;

State lastDisplayState = (State)-1;
float lastDisplayedPH = -999.0;
float lastDisplayedTemp = -999.0;
float lastDisplayedPIdeal = -999.0;
bool lastAlertState = false;

// Protótipos
void loadSettings();
void saveSettings();
void readTemperature();
void readpH();
void updateDisplay();
void checkButtons();
void controlPump();
float averagePH();
bool isPHStable();
void handleMain();
void handleMenu();
void handleAdjustPH();
void handleCalibrate();
void handleCalibrateMode();
void handleCalibrateOnePoint();
void handleCalibrateTwoPointFirst();
void handleCalibrateTwoPointSecond();
void handleInitialCalibrationPrompt();
bool waitForMenuConfirm();

void setup() {
  Serial.begin(9600);
  pinMode(upButton, BUTTON_LOGIC_INVERTED ? INPUT : INPUT_PULLUP);
  pinMode(downButton, BUTTON_LOGIC_INVERTED ? INPUT : INPUT_PULLUP);
  pinMode(menuButton, BUTTON_LOGIC_INVERTED ? INPUT : INPUT_PULLUP);
  pinMode(pumpPin, OUTPUT);
  pinMode(ledPin, OUTPUT);
  digitalWrite(pumpPin, LOW);
  digitalWrite(ledPin, LOW);

  lcd.init();
  lcd.backlight();
  lcd.print("Iniciando sistema...");
  delay(1500);
  
  sensors.begin();
  
  if (EEPROM.read(FIRST_RUN_FLAG_ADDR) != 123) {
    currentState = INITIAL_CALIBRATION_PROMPT;
    EEPROM.write(FIRST_RUN_FLAG_ADDR, 123);
  }
  
  loadSettings();
  
  for (int i = 0; i < PH_READING_COUNT; i++) {
    pHReadings[i] = 7.0;
  }

  wdt_enable(WDTO_4S); // Habilita o Watchdog com um timeout de 4 segundos
}

void loop() {
  wdt_reset(); // Reseta o watchdog em cada ciclo para indicar que o sistema está funcionando

  if (millis() - lastTempReadTime >= 2000) {
    lastTempReadTime = millis();
    readTemperature();
  }
  if (millis() - lastPhReadTime >= 1000) {
    lastPhReadTime = millis();
    readpH();
  }

  checkButtons();
  controlPump();
  updateDisplay();
  
  switch (currentState) {
    case MAIN: handleMain(); break;
    case MENU: handleMenu(); break;
    case ADJUST_PH: handleAdjustPH(); break;
    case CALIBRATE: handleCalibrate(); break;
    case CALIBRATE_MODE: handleCalibrateMode(); break;
    case CALIBRATE_ONE_POINT: handleCalibrateOnePoint(); break;
    case CALIBRATE_TWO_POINT_FIRST: handleCalibrateTwoPointFirst(); break;
    case CALIBRATE_TWO_POINT_SECOND: handleCalibrateTwoPointSecond(); break;
    case INITIAL_CALIBRATION_PROMPT: handleInitialCalibrationPrompt(); break;
  }
}

void readTemperature() {
  sensors.requestTemperatures();
  float t = sensors.getTempCByIndex(0);
  if (t != DEVICE_DISCONNECTED_C && !isnan(t) && t > -40 && t < 125) {
    temperature = t;
  }
}

void readpH() {
  int analogValue = analogRead(pHPin);
  float voltage = analogValue * (ADC_REF / ADC_MAX);
  if (fabs(pHSlope) < 1e-6) return;
  float tempK = temperature + 273.15;
  float slopeT = pHSlope * (tempK / KELVIN_25);
  if (fabs(slopeT) < 1e-6) return;
  float pHcalc = (voltage - pHOffset) / slopeT;
  if (!isnan(pHcalc) && pHcalc > -5 && pHcalc < 20) {
    pHValue = pHcalc;
    pHReadings[readingIndex] = pHValue;
    readingIndex = (readingIndex + 1) % PH_READING_COUNT;
  }
}

void controlPump() {
  if (averagePH() < pHIdeal - 0.3) {
    pHBelowIdeal = true;
    digitalWrite(ledPin, HIGH);
    if (pumpActive) {
      digitalWrite(pumpPin, LOW);
      pumpActive = false;
      waitingAfterPump = true;
      lastPumpTime = millis();
    }
    return;
  } else {
    pHBelowIdeal = false;
    digitalWrite(ledPin, LOW);
  }
  if (!isPHStable()) return;
  float phAvg = averagePH();
  if (phAvg > pHIdeal + 0.3 && !waitingAfterPump && !pumpActive) {
    pumpActive = true;
    digitalWrite(pumpPin, HIGH);
    lastPumpTime = millis();
  }
  if (pumpActive && millis() - lastPumpTime >= pumpDuration) {
    digitalWrite(pumpPin, LOW);
    pumpActive = false;
    waitingAfterPump = true;
    lastPumpTime = millis();
  }
  if (waitingAfterPump && millis() - lastPumpTime >= waitAfterPump) {
    waitingAfterPump = false;
  }
}

void updateDisplay() {
    if (lastDisplayState != currentState) {
        lcd.clear();
        lastDisplayState = currentState;
        lastDisplayedPH = -999.0;
        lastDisplayedTemp = -999.0;
        lastDisplayedPIdeal = -999.0;
        lastAlertState = !pHBelowIdeal;
    }

    switch (currentState) {
        case MAIN: {
            if (lastAlertState != pHBelowIdeal) {
                lcd.clear(); // Limpa a tela na transição de/para o estado de alerta
                lastAlertState = pHBelowIdeal;
                lastDisplayedPH = -999.0; // Força redesenho
            }

            if (pHBelowIdeal) {
                lcd.setCursor(0, 0); lcd.print("** ALERTA: PH BAIXO **");
            } else {
                const char spinner[] = {'|', '/', '-', '\\'};
                char indicator = spinner[readingIndex % 4];
                lcd.setCursor(0, 0); lcd.print("STATUS ATUAL "); lcd.print(indicator); lcd.print("      ");
            }

            float currentAveragePH = averagePH();
            if (fabs(lastDisplayedPH - currentAveragePH) > 0.05 || fabs(lastDisplayedTemp - temperature) > 0.2 || fabs(lastDisplayedPIdeal - pHIdeal) > 0.05) {
                lcd.setCursor(0, 1); lcd.print("PH Medio: "); lcd.print(currentAveragePH, 2); lcd.print("      ");
                lcd.setCursor(0, 2); lcd.print("PH Inst.: "); lcd.print(pHValue, 2); lcd.print("      ");
                lcd.setCursor(0, 3); lcd.print("T:"); lcd.print(temperature, 1); lcd.print((char)223); lcd.print("C "); lcd.print("Ideal:"); lcd.print(pHIdeal, 1); lcd.print("   ");
                lastDisplayedPH = currentAveragePH;
                lastDisplayedTemp = temperature;
                lastDisplayedPIdeal = pHIdeal;
            }
            break;
        }
        case MENU:
            lcd.setCursor(0, 0); lcd.print("MENU               ");
            lcd.setCursor(0, 1); lcd.print(menuIndex == 0 ? "> Ajustar PH Ideal" : "  Ajustar PH Ideal");
            lcd.setCursor(0, 2); lcd.print(menuIndex == 1 ? "> Calibrar Sonda  " : "  Calibrar Sonda  ");
            lcd.setCursor(0, 3); lcd.print(menuIndex == 2 ? "> Voltar          " : "  Voltar          ");
            break;
        case ADJUST_PH:
            lcd.setCursor(0, 0); lcd.print("Selecione PH Ideal ");
            lcd.setCursor(0, 1); lcd.print("Valor: "); lcd.print(pHIdeal, 2); lcd.print("        ");
            lcd.setCursor(0, 3); lcd.print("MENU-confirma      ");
            break;
        case CALIBRATE:
            lcd.setCursor(0, 0); lcd.print("CALIBRAR SONDA     ");
            lcd.setCursor(0, 1); lcd.print(menuIndex == 0 ? "> Um Ponto        " : "  Um Ponto        ");
            lcd.setCursor(0, 2); lcd.print(menuIndex == 1 ? "> Dois Pontos     " : "  Dois Pontos     ");
            lcd.setCursor(0, 3); lcd.print(menuIndex == 2 ? "> Voltar          " : "  Voltar          ");
            break;
        case CALIBRATE_MODE:
        case INITIAL_CALIBRATION_PROMPT:
            lcd.setCursor(0, 0); lcd.print(currentState == CALIBRATE_MODE ? "Selecione Modo     " : "Calibrar sensor?   ");
            lcd.setCursor(0, 1); lcd.print(calibMenuIndex == 0 ? "> Um Ponto        " : "  Um Ponto        ");
            lcd.setCursor(0, 2); lcd.print(calibMenuIndex == 1 ? "> Dois Pontos     " : "  Dois Pontos     ");
            lcd.setCursor(0, 3); lcd.print(calibMenuIndex == 2 ? "> Voltar          " : "  Voltar          ");
            break;
    }
}

void checkButtons() {
    const bool PRESSED_STATE = BUTTON_LOGIC_INVERTED ? HIGH : LOW;
    const bool RELEASED_STATE = !PRESSED_STATE;
    static bool lastUpRaw = RELEASED_STATE, lastDownRaw = RELEASED_STATE, lastMenuRaw = RELEASED_STATE;
    static unsigned long tUp = 0, tDown = 0, tMenu = 0;
    const unsigned long DEBOUNCE_MS = 25;
    bool rawUp = digitalRead(upButton);
    if (rawUp != lastUpRaw) tUp = millis();
    if (millis() - tUp > DEBOUNCE_MS) upPressed = (rawUp == PRESSED_STATE);
    lastUpRaw = rawUp;
    bool rawDown = digitalRead(downButton);
    if (rawDown != lastDownRaw) tDown = millis();
    if (millis() - tDown > DEBOUNCE_MS) downPressed = (rawDown == PRESSED_STATE);
    lastDownRaw = rawDown;
    bool rawMenu = digitalRead(menuButton);
    if (rawMenu != lastMenuRaw) tMenu = millis();
    if (millis() - tMenu > DEBOUNCE_MS) {
        if (rawMenu == PRESSED_STATE && lastMenuRaw == RELEASED_STATE) lastButtonPress = millis();
        menuPressed = (rawMenu == PRESSED_STATE);
    }
    lastMenuRaw = rawMenu;
    if (currentState != MAIN && millis() - lastButtonPress > timeout) {
        currentState = MAIN;
    }
}

void handleMain() {
    if (menuPressed) { currentState = MENU; menuPressed = false; }
    else if (upPressed || downPressed) { currentState = ADJUST_PH; upPressed = false; downPressed = false; }
}

void handleMenu() {
    if (upPressed) { menuIndex = (menuIndex - 1 + 3) % 3; upPressed = false; }
    else if (downPressed) { menuIndex = (menuIndex + 1) % 3; downPressed = false; }
    else if (menuPressed) {
        switch (menuIndex) {
            case 0: currentState = ADJUST_PH; break;
            case 1: currentState = CALIBRATE; menuIndex = 0; break;
            case 2: currentState = MAIN; break;
        }
        menuPressed = false;
    }
}

void handleAdjustPH() {
    if (upPressed) { pHIdeal += 0.1; if (pHIdeal > 14.0) pHIdeal = 14.0; upPressed = false; lastButtonPress = millis(); }
    else if (downPressed) { pHIdeal -= 0.1; if (pHIdeal < 0.0) pHIdeal = 0.0; downPressed = false; lastButtonPress = millis(); }
    else if (menuPressed) { saveSettings(); currentState = MAIN; menuPressed = false; }
}

void handleCalibrate() {
    if (upPressed) { menuIndex = (menuIndex - 1 + 3) % 3; upPressed = false; }
    else if (downPressed) { menuIndex = (menuIndex + 1) % 3; downPressed = false; }
    else if (menuPressed) {
        switch (menuIndex) {
            case 0: currentState = CALIBRATE_ONE_POINT; calibSolutionIndex = 0; break;
            case 1: currentState = CALIBRATE_TWO_POINT_FIRST; calibSolutionIndex = 0; break;
            case 2: currentState = MAIN; break;
        }
        menuPressed = false;
    }
}

void handleInitialCalibrationPrompt() {
    if (upPressed) { calibMenuIndex = (calibMenuIndex - 1 + 3) % 3; upPressed = false; }
    else if (downPressed) { calibMenuIndex = (calibMenuIndex + 1) % 3; downPressed = false; }
    else if (menuPressed) {
        switch (calibMenuIndex) {
            case 0: currentState = CALIBRATE_ONE_POINT; calibSolutionIndex = 0; break;
            case 1: currentState = CALIBRATE_TWO_POINT_FIRST; calibSolutionIndex = 0; break;
            case 2: currentState = MAIN; break;
        }
        menuPressed = false;
    }
}

void handleCalibrateMode() { handleInitialCalibrationPrompt(); }

bool waitForMenuConfirm() {
    lcd.setCursor(0, 2); lcd.print("Press MENU quando "); lcd.setCursor(0, 3); lcd.print("pronto             ");
    while (true) {
        wdt_reset(); checkButtons();
        if (menuPressed) { menuPressed = false; delay(120); return true; }
        delay(80);
    }
}

void handleCalibrateOnePoint() {
    lcd.setCursor(0, 0); lcd.print("CALIBRAR: 1 PONTO  ");
    lcd.setCursor(0, 1); lcd.print(calibSolutionIndex == 0 ? "> Solucao 4.01" : "  Solucao 4.01");
    lcd.setCursor(0, 2); lcd.print(calibSolutionIndex == 1 ? "> Solucao 7.01" : "  Solucao 7.01");
    lcd.setCursor(0, 3); lcd.print(calibSolutionIndex == 2 ? "> Solucao 10.01" : "  Solucao 10.01");
    if (upPressed) { calibSolutionIndex = (calibSolutionIndex - 1 + 3) % 3; upPressed = false; }
    else if (downPressed) { calibSolutionIndex = (calibSolutionIndex + 1) % 3; downPressed = false; }
    else if (menuPressed) {
        menuPressed = false;
        lcd.clear(); lcd.print("Mergulhe a sonda"); lcd.setCursor(0, 1); lcd.print("na solucao e espere");
        waitForMenuConfirm();
        lcd.clear(); lcd.print("CALIBRANDO...");
        float sum = 0;
        for (int i = 0; i < PH_READING_COUNT; i++) {
            wdt_reset();
            int analogValue = analogRead(pHPin); float voltage = analogValue * (ADC_REF / ADC_MAX); sum += voltage;
            lcd.setCursor(0, 1); lcd.print("Leitura "); lcd.print(i + 1); lcd.print("/"); lcd.print(PH_READING_COUNT);
            lcd.setCursor(0, 2); lcd.print("Tensao: "); lcd.print(voltage, 3); lcd.print("V   ");
            delay(250);
        }
        float avgVoltage = sum / (float)PH_READING_COUNT;
        float targetpH = 0;
        switch (calibSolutionIndex) { case 0: targetpH = calibpH4; break; case 1: targetpH = calibpH7; break; case 2: targetpH = calibpH10; break; }
        if (fabs(pHSlope) < 1e-6) {
            lcd.clear(); lcd.print("Slope invalido.  "); lcd.setCursor(0,1); lcd.print("Faça 2 pontos"); delay(2500);
        } else {
            pHOffset = avgVoltage - (pHSlope * targetpH); saveSettings();
            lcd.clear(); lcd.print("Calibracao"); lcd.setCursor(0, 1); lcd.print("Concluida!"); delay(1500);
        }
        currentState = MAIN;
    }
}

void handleCalibrateTwoPointFirst() {
    lcd.setCursor(0, 0); lcd.print("CALIBRAR: PONTO 1/2");
    lcd.setCursor(0, 1); lcd.print(calibSolutionIndex == 0 ? "> Solucao 4.01" : "  Solucao 4.01");
    lcd.setCursor(0, 2); lcd.print(calibSolutionIndex == 1 ? "> Solucao 7.01" : "  Solucao 7.01");
    lcd.setCursor(0, 3); lcd.print(calibSolutionIndex == 2 ? "> Solucao 10.01" : "  Solucao 10.01");
    if (upPressed) { calibSolutionIndex = (calibSolutionIndex - 1 + 3) % 3; upPressed = false; }
    else if (downPressed) { calibSolutionIndex = (calibSolutionIndex + 1) % 3; downPressed = false; }
    else if (menuPressed) {
        menuPressed = false;
        selectedCalibPoint = calibSolutionIndex;
        lcd.clear(); lcd.print("Mergulhe a sonda"); lcd.setCursor(0, 1); lcd.print("na solucao e espere");
        waitForMenuConfirm();
        lcd.clear(); lcd.print("CALIBRANDO...");
        float sum = 0;
        for (int i = 0; i < PH_READING_COUNT; i++) {
            wdt_reset();
            int analogValue = analogRead(pHPin); float voltage = analogValue * (ADC_REF / ADC_MAX); sum += voltage;
            lcd.setCursor(0, 1); lcd.print("Leitura "); lcd.print(i + 1); lcd.print("/"); lcd.print(PH_READING_COUNT);
            lcd.setCursor(0, 2); lcd.print("Tensao: "); lcd.print(voltage, 3); lcd.print("V   ");
            delay(250);
        }
        firstCalibValue = sum / (float)PH_READING_COUNT;
        lcd.clear(); lcd.print("Primeiro ponto"); lcd.setCursor(0, 1); lcd.print("calibrado!"); delay(1200);
        currentState = CALIBRATE_TWO_POINT_SECOND; calibSolutionIndex = 0;
    }
}

void handleCalibrateTwoPointSecond() {
    lcd.setCursor(0, 0); lcd.print("CALIBRAR: PONTO 2/2");
    if (upPressed) { do { calibSolutionIndex = (calibSolutionIndex - 1 + 3) % 3; } while (calibSolutionIndex == selectedCalibPoint); upPressed = false; }
    else if (downPressed) { do { calibSolutionIndex = (calibSolutionIndex + 1) % 3; } while (calibSolutionIndex == selectedCalibPoint); downPressed = false; }
    lcd.setCursor(0, 1); lcd.print((calibSolutionIndex == 0 && selectedCalibPoint != 0) ? "> Solucao 4.01" : "  Solucao 4.01");
    lcd.setCursor(0, 2); lcd.print((calibSolutionIndex == 1 && selectedCalibPoint != 1) ? "> Solucao 7.01" : "  Solucao 7.01");
    lcd.setCursor(0, 3); lcd.print((calibSolutionIndex == 2 && selectedCalibPoint != 2) ? "> Solucao 10.01" : "  Solucao 10.01");
    if (menuPressed) {
        menuPressed = false;
        lcd.clear(); lcd.print("Mergulhe a sonda"); lcd.setCursor(0, 1); lcd.print("na solucao e espere");
        waitForMenuConfirm();
        lcd.clear(); lcd.print("CALIBRANDO...");
        float sum = 0;
        for (int i = 0; i < PH_READING_COUNT; i++) {
            wdt_reset();
            int analogValue = analogRead(pHPin); float voltage = analogValue * (ADC_REF / ADC_MAX); sum += voltage;
            lcd.setCursor(0, 1); lcd.print("Leitura "); lcd.print(i + 1); lcd.print("/"); lcd.print(PH_READING_COUNT);
            lcd.setCursor(0, 2); lcd.print("Tensao: "); lcd.print(voltage, 3); lcd.print("V   ");
            delay(250);
        }
        float secondCalibValue = sum / (float)PH_READING_COUNT;
        float targetpH1 = 0, targetpH2 = 0;
        switch (selectedCalibPoint) { case 0: targetpH1 = calibpH4; break; case 1: targetpH1 = calibpH7; break; case 2: targetpH1 = calibpH10; break; }
        switch (calibSolutionIndex) { case 0: targetpH2 = calibpH4; break; case 1: targetpH2 = calibpH7; break; case 2: targetpH2 = calibpH10; break; }
        float denom = (targetpH2 - targetpH1);
        if (fabs(denom) < 1e-6) {
            lcd.clear(); lcd.print("Erro: pontos iguais "); delay(1500);
        } else {
            float newSlope = (secondCalibValue - firstCalibValue) / denom;
            if (newSlope > -0.040 || newSlope < -0.080) {
                lcd.clear(); lcd.print("Erro de Calibracao"); lcd.setCursor(0, 1); lcd.print("Slope invalido!"); delay(3000);
            } else {
                pHSlope = newSlope; pHOffset = firstCalibValue - (pHSlope * targetpH1); saveSettings();
                lcd.clear(); lcd.print("Calibracao"); lcd.setCursor(0, 1); lcd.print("Concluida!"); delay(1500);
            }
        }
        currentState = MAIN;
    }
}

float averagePH() {
  float sortedReadings[PH_READING_COUNT];
  for (int i = 0; i < PH_READING_COUNT; i++) sortedReadings[i] = pHReadings[i];
  for (int i = 0; i < PH_READING_COUNT - 1; i++) {
    for (int j = 0; j < PH_READING_COUNT - i - 1; j++) {
      if (sortedReadings[j] > sortedReadings[j + 1]) {
        float temp = sortedReadings[j];
        sortedReadings[j] = sortedReadings[j + 1];
        sortedReadings[j + 1] = temp;
      }
    }
  }
  float sum = 0;
  for (int i = 2; i < PH_READING_COUNT - 2; i++) sum += sortedReadings[i];
  return sum / (float)(PH_READING_COUNT - 4);
}

bool isPHStable() {
  float minVal = pHReadings[0];
  float maxVal = pHReadings[0];
  for (int i = 1; i < PH_READING_COUNT; i++) {
    if (pHReadings[i] < minVal) minVal = pHReadings[i];
    if (pHReadings[i] > maxVal) maxVal = pHReadings[i];
  }
  return (maxVal - minVal) <= 0.2;
}

void pHStabilityCheck() {}

void loadSettings() {
  EEPROM.get(PH_IDEAL_ADDR, pHIdeal);
  EEPROM.get(PH_OFFSET_ADDR, pHOffset);
  EEPROM.get(PH_SLOPE_ADDR, pHSlope);
  if (isnan(pHIdeal) || pHIdeal < 0 || pHIdeal > 14) pHIdeal = 6.0;
  if (isnan(pHOffset)) pHOffset = 0.0;
  if (isnan(pHSlope) || pHSlope <= 0) pHSlope = 1.0;
}

void saveSettings() {
  float temp;
  EEPROM.get(PH_IDEAL_ADDR, temp);
  if (temp != pHIdeal) EEPROM.put(PH_IDEAL_ADDR, pHIdeal);
  EEPROM.get(PH_OFFSET_ADDR, temp);
  if (temp != pHOffset) EEPROM.put(PH_OFFSET_ADDR, pHOffset);
  EEPROM.get(PH_SLOPE_ADDR, temp);
  if (temp != pHSlope) EEPROM.put(PH_SLOPE_ADDR, pHSlope);
}
