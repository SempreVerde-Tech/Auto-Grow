/*
  Sistema de Controle de pH Automático
  Para Arduino Nano com sensor de pH, temperatura, display LCD e bomba peristáltica
  Versão Corrigida por Jules
*/

#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <EEPROM.h>

LiquidCrystal_I2C lcd(0x27, 20, 4);

#define ONE_WIRE_BUS 2
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);

const int pHPin = A0;
const int upButton = 3;
const int downButton = 4;
const int menuButton = 5;
const int pumpPin = 6;
const int ledPin = 7;

const float ADC_REF = 5.0;
const float ADC_MAX = 1023.0;
const float KELVIN_25 = 298.15;

float pHValue;
float temperature;
float pHIdeal = 6.0;
float pHOffset = 0.0;
float pHSlope = 1.0;

const float calibpH4 = 4.01;
const float calibpH7 = 7.01;
const float calibpH10 = 10.01;

enum State {
  MAIN, MENU, ADJUST_PH, CALIBRATE, CALIBRATE_MODE,
  CALIBRATE_ONE_POINT, CALIBRATE_TWO_POINT_FIRST, CALIBRATE_TWO_POINT_SECOND,
  INITIAL_CALIBRATION_PROMPT
};
State currentState = MAIN;

bool upPressed = false;
bool downPressed = false;
bool menuPressed = false;
unsigned long lastButtonPress = 0;
const unsigned long timeout = 30000;

const int PH_READING_COUNT = 10;
float pHReadings[PH_READING_COUNT];
int readingIndex = 0;
unsigned long lastPumpTime = 0;
unsigned long lastPhReadTime = 0;
const unsigned long pumpDuration = 10000;
const unsigned long waitAfterPump = 300000;
bool pumpActive = false;
bool waitingAfterPump = false;
bool pHBelowIdeal = false;

#define FIRST_RUN_FLAG_ADDR 1023
#define PH_IDEAL_ADDR 0
#define PH_OFFSET_ADDR 4
#define PH_SLOPE_ADDR 8

int menuIndex = 0;
int calibMenuIndex = 0;
int calibSolutionIndex = 0;
float firstCalibValue = 0;
int selectedCalibPoint = 0;

State lastDisplayState = (State)-1;
float lastDisplayedPH = -999.0;
float lastDisplayedTemp = -999.0;
float lastDisplayedPIdeal = -999.0;
bool lastAlertState = false;

void setup() {
  Serial.begin(9600);
  pinMode(upButton, INPUT_PULLUP);
  pinMode(downButton, INPUT_PULLUP);
  pinMode(menuButton, INPUT_PULLUP);
  pinMode(pumpPin, OUTPUT);
  pinMode(ledPin, OUTPUT);
  digitalWrite(pumpPin, LOW);
  digitalWrite(ledPin, LOW);

  lcd.init();
  lcd.backlight();
  lcd.print("Iniciando sistema...");
  delay(1500);
  
  sensors.begin();
  
  if (EEPROM.read(FIRST_RUN_FLAG_ADDR) != 123) {
    currentState = INITIAL_CALIBRATION_PROMPT;
    EEPROM.write(FIRST_RUN_FLAG_ADDR, 123);
  }
  
  loadSettings();
  
  for (int i = 0; i < PH_READING_COUNT; i++) {
    pHReadings[i] = 7.0;
  }
}

void loop() {
  readTemperature();
  if (millis() - lastPhReadTime >= 1000) {
    lastPhReadTime = millis();
    readpH();
  }
  checkButtons();
  controlPump();
  updateDisplay();
  
  switch (currentState) {
    case MAIN: handleMain(); break;
    case MENU: handleMenu(); break;
    case ADJUST_PH: handleAdjustPH(); break;
    case CALIBRATE: handleCalibrate(); break;
    case CALIBRATE_MODE: handleCalibrateMode(); break;
    case CALIBRATE_ONE_POINT: handleCalibrateOnePoint(); break;
    case CALIBRATE_TWO_POINT_FIRST: handleCalibrateTwoPointFirst(); break;
    case CALIBRATE_TWO_POINT_SECOND: handleCalibrateTwoPointSecond(); break;
    case INITIAL_CALIBRATION_PROMPT: handleInitialCalibrationPrompt(); break;
  }
  delay(50);
}

void readTemperature() {
  sensors.requestTemperatures();
  float t = sensors.getTempCByIndex(0);
  if (t == DEVICE_DISCONNECTED_C || isnan(t) || t < -40 || t > 125) {
    temperature = 25.0;
  } else {
    temperature = t;
  }
}

void readpH() {
  int analogValue = analogRead(pHPin);
  float voltage = analogValue * (ADC_REF / ADC_MAX);
  if (fabs(pHSlope) < 1e-6) return;
  float tempK = temperature + 273.15;
  float slopeT = pHSlope * (tempK / KELVIN_25);
  if (fabs(slopeT) < 1e-6) return;
  float pHcalc = (voltage - pHOffset) / slopeT;
  if (!isnan(pHcalc) && pHcalc > -5 && pHcalc < 20) {
    pHValue = pHcalc;
    pHReadings[readingIndex] = pHValue;
    readingIndex = (readingIndex + 1) % PH_READING_COUNT;
  }
}

void updateDisplay() {
    if (lastDisplayState != currentState) {
        lcd.clear();
        lastDisplayState = currentState;
        lastDisplayedPH = -999.0;
        lastDisplayedTemp = -999.0;
        lastDisplayedPIdeal = -999.0;
        lastAlertState = !pHBelowIdeal;
    }

    switch (currentState) {
        case MAIN: {
            float currentAveragePH = averagePH();
            bool dataChanged = fabs(lastDisplayedPH - currentAveragePH) > 0.05 ||
                               fabs(lastDisplayedTemp - temperature) > 0.2 ||
                               fabs(lastDisplayedPIdeal - pHIdeal) > 0.05;
            bool alertStateChanged = lastAlertState != pHBelowIdeal;

            if (alertStateChanged) {
                dataChanged = true;
                lastAlertState = pHBelowIdeal;
            }

            if (dataChanged) {
                if (pHBelowIdeal) {
                    lcd.setCursor(0, 0);
                    lcd.print("** ALERTA: PH BAIXO **");
                } else {
                    const char spinner[] = {'|', '/', '-', '\\'};
                    char indicator = spinner[readingIndex % 4];
                    lcd.setCursor(0, 0);
                    lcd.print("STATUS ATUAL ");
                    lcd.print(indicator);
                    lcd.print("      ");
                }

                lcd.setCursor(0, 1);
                lcd.print("PH Medio: ");
                lcd.print(currentAveragePH, 2);
                lcd.print("      ");

                lcd.setCursor(0, 2);
                lcd.print("PH Inst.: ");
                lcd.print(pHValue, 2);
                lcd.print("      ");

                lcd.setCursor(0, 3);
                lcd.print("T:");
                lcd.print(temperature, 1);
                lcd.print((char)223);
                lcd.print("C ");
                lcd.print("Ideal:");
                lcd.print(pHIdeal, 1);
                lcd.print("   ");

                lastDisplayedPH = currentAveragePH;
                lastDisplayedTemp = temperature;
                lastDisplayedPIdeal = pHIdeal;
            } else if (!pHBelowIdeal) {
                const char spinner[] = {'|', '/', '-', '\\'};
                char indicator = spinner[readingIndex % 4];
                lcd.setCursor(13, 0);
                lcd.print(indicator);
            }
            break;
        }
        case MENU:
            lcd.setCursor(0, 0);
            lcd.print("MENU               ");
            lcd.setCursor(0, 1);
            lcd.print(menuIndex == 0 ? "> Ajustar PH Ideal" : "  Ajustar PH Ideal");
            lcd.setCursor(0, 2);
            lcd.print(menuIndex == 1 ? "> Calibrar Sonda  " : "  Calibrar Sonda  ");
            lcd.setCursor(0, 3);
            lcd.print(menuIndex == 2 ? "> Voltar          " : "  Voltar          ");
            break;
        case ADJUST_PH:
            lcd.setCursor(0, 0);
            lcd.print("Selecione PH Ideal ");
            lcd.setCursor(0, 1);
            lcd.print("Valor: ");
            lcd.print(pHIdeal, 2);
            lcd.print("        ");
            lcd.setCursor(0, 3);
            lcd.print("MENU-confirma      ");
            break;
        case CALIBRATE:
            lcd.setCursor(0, 0);
            lcd.print("CALIBRAR SONDA     ");
            lcd.setCursor(0, 1);
            lcd.print(menuIndex == 0 ? "> Um Ponto        " : "  Um Ponto        ");
            lcd.setCursor(0, 2);
            lcd.print(menuIndex == 1 ? "> Dois Pontos     " : "  Dois Pontos     ");
            lcd.setCursor(0, 3);
            lcd.print(menuIndex == 2 ? "> Voltar          " : "  Voltar          ");
            break;
        case CALIBRATE_MODE:
        case INITIAL_CALIBRATION_PROMPT:
            lcd.setCursor(0, 0);
            lcd.print(currentState == CALIBRATE_MODE ? "Selecione Modo     " : "Calibrar sensor?   ");
            lcd.setCursor(0, 1);
            lcd.print(calibMenuIndex == 0 ? "> Um Ponto        " : "  Um Ponto        ");
            lcd.setCursor(0, 2);
            lcd.print(calibMenuIndex == 1 ? "> Dois Pontos     " : "  Dois Pontos     ");
            lcd.setCursor(0, 3);
            lcd.print(calibMenuIndex == 2 ? "> Voltar          " : "  Voltar          ");
            break;
        case CALIBRATE_ONE_POINT:
        case CALIBRATE_TWO_POINT_FIRST:
        case CALIBRATE_TWO_POINT_SECOND:
            break;
    }
}

void checkButtons() {
    static bool lastUpRaw = HIGH, lastDownRaw = HIGH, lastMenuRaw = HIGH;
    static unsigned long tUp = 0, tDown = 0, tMenu = 0;
    const unsigned long DEBOUNCE_MS = 40;
    bool rawUp = digitalRead(upButton);
    if (rawUp != lastUpRaw) tUp = millis();
    if (millis() - tUp > DEBOUNCE_MS) upPressed = (rawUp == LOW);
    lastUpRaw = rawUp;
    bool rawDown = digitalRead(downButton);
    if (rawDown != lastDownRaw) tDown = millis();
    if (millis() - tDown > DEBOUNCE_MS) downPressed = (rawDown == LOW);
    lastDownRaw = rawDown;
    bool rawMenu = digitalRead(menuButton);
    if (rawMenu != lastMenuRaw) tMenu = millis();
    if (millis() - tMenu > DEBOUNCE_MS) {
        if (rawMenu == LOW && lastMenuRaw == HIGH) lastButtonPress = millis();
        menuPressed = (rawMenu == LOW);
    }
    lastMenuRaw = rawMenu;
    if (currentState != MAIN && millis() - lastButtonPress > timeout) {
        currentState = MAIN;
    }
}

void handleMain() {
    if (menuPressed) { currentState = MENU; menuPressed = false; }
    else if (upPressed || downPressed) { currentState = ADJUST_PH; upPressed = false; downPressed = false; }
}

void handleMenu() {
    if (upPressed) { menuIndex = (menuIndex - 1 + 3) % 3; upPressed = false; }
    else if (downPressed) { menuIndex = (menuIndex + 1) % 3; downPressed = false; }
    else if (menuPressed) {
        switch (menuIndex) {
            case 0: currentState = ADJUST_PH; break;
            case 1: currentState = CALIBRATE; menuIndex = 0; break;
            case 2: currentState = MAIN; break;
        }
        menuPressed = false;
    }
}

void handleAdjustPH() {
    if (upPressed) { pHIdeal += 0.1; if (pHIdeal > 14.0) pHIdeal = 14.0; upPressed = false; lastButtonPress = millis(); }
    else if (downPressed) { pHIdeal -= 0.1; if (pHIdeal < 0.0) pHIdeal = 0.0; downPressed = false; lastButtonPress = millis(); }
    else if (menuPressed) { saveSettings(); currentState = MAIN; menuPressed = false; }
}

void handleCalibrate() {
    if (upPressed) { menuIndex = (menuIndex - 1 + 3) % 3; upPressed = false; }
    else if (downPressed) { menuIndex = (menuIndex + 1) % 3; downPressed = false; }
    else if (menuPressed) {
        switch (menuIndex) {
            case 0: currentState = CALIBRATE_ONE_POINT; calibSolutionIndex = 0; break;
            case 1: currentState = CALIBRATE_TWO_POINT_FIRST; calibSolutionIndex = 0; break;
            case 2: currentState = MAIN; break;
        }
        menuPressed = false;
    }
}

void handleInitialCalibrationPrompt() {
    if (upPressed) { calibMenuIndex = (calibMenuIndex - 1 + 3) % 3; upPressed = false; }
    else if (downPressed) { calibMenuIndex = (calibMenuIndex + 1) % 3; downPressed = false; }
    else if (menuPressed) {
        switch (calibMenuIndex) {
            case 0: currentState = CALIBRATE_ONE_POINT; calibSolutionIndex = 0; break;
            case 1: currentState = CALIBRATE_TWO_POINT_FIRST; calibSolutionIndex = 0; break;
            case 2: currentState = MAIN; break;
        }
        menuPressed = false;
    }
}

void handleCalibrateMode() { handleInitialCalibrationPrompt(); }

bool waitForMenuConfirm() {
    lcd.setCursor(0, 2); lcd.print("Press MENU quando "); lcd.setCursor(0, 3); lcd.print("pronto             ");
    while (true) {
        checkButtons(); readTemperature(); readpH();
        if (menuPressed) { menuPressed = false; delay(120); return true; }
        delay(80);
    }
}

void handleCalibrateOnePoint() {
    if (upPressed) { calibSolutionIndex = (calibSolutionIndex - 1 + 3) % 3; upPressed = false; }
    else if (downPressed) { calibSolutionIndex = (calibSolutionIndex + 1) % 3; downPressed = false; }
    else if (menuPressed) {
        lcd.clear(); lcd.print("Mergulhe a sonda"); lcd.setCursor(0, 1);
        lcd.print("na solucao ");
        switch (calibSolutionIndex) { case 0: lcd.print("4.01"); break; case 1: lcd.print("7.01"); break; case 2: lcd.print("10.01"); break; }
        waitForMenuConfirm();
        lcd.clear(); lcd.print("CALIBRANDO...");
        float sum = 0;
        for (int i = 0; i < PH_READING_COUNT; i++) {
            int analogValue = analogRead(pHPin); float voltage = analogValue * (ADC_REF / ADC_MAX); sum += voltage;
            lcd.setCursor(0, 1); lcd.print("Leitura " + String(i + 1) + "/" + String(PH_READING_COUNT) + "   ");
            lcd.setCursor(0, 2); lcd.print("Tensao: " + String(voltage, 3) + "V   ");
            sensors.requestTemperatures(); delay(250);
        }
        float avgVoltage = sum / 10.0;
        float targetpH = 0;
        switch (calibSolutionIndex) { case 0: targetpH = calibpH4; break; case 1: targetpH = calibpH7; break; case 2: targetpH = calibpH10; break; }
        if (fabs(pHSlope) < 1e-6) {
            lcd.clear(); lcd.print("Slope invalido.  "); lcd.setCursor(0,1); lcd.print("Faça 2 pontos"); delay(2500);
        } else {
            pHOffset = avgVoltage - (pHSlope * targetpH); saveSettings();
            lcd.clear(); lcd.print("Calibracao"); lcd.setCursor(0, 1); lcd.print("Concluida!"); delay(1500);
        }
        currentState = MAIN; menuPressed = false;
    }
}

void handleCalibrateTwoPointFirst() {
    if (upPressed) { calibSolutionIndex = (calibSolutionIndex - 1 + 3) % 3; upPressed = false; }
    else if (downPressed) { calibSolutionIndex = (calibSolutionIndex + 1) % 3; downPressed = false; }
    else if (menuPressed) {
        selectedCalibPoint = calibSolutionIndex;
        lcd.clear(); lcd.print("Mergulhe a sonda"); lcd.setCursor(0, 1);
        lcd.print("na solucao ");
        switch (calibSolutionIndex) { case 0: lcd.print("4.01"); break; case 1: lcd.print("7.01"); break; case 2: lcd.print("10.01"); break; }
        waitForMenuConfirm();
        lcd.clear(); lcd.print("CALIBRANDO...");
        float sum = 0;
        for (int i = 0; i < PH_READING_COUNT; i++) {
            int analogValue = analogRead(pHPin); float voltage = analogValue * (ADC_REF / ADC_MAX); sum += voltage;
            lcd.setCursor(0, 1); lcd.print("Leitura " + String(i + 1) + "/" + String(PH_READING_COUNT) + "   ");
            lcd.setCursor(0, 2); lcd.print("Tensao: " + String(voltage, 3) + "V   ");
            delay(250);
        }
        firstCalibValue = sum / 10.0;
        lcd.clear(); lcd.print("Primeiro ponto"); lcd.setCursor(0, 1); lcd.print("calibrado!"); delay(1200);
        currentState = CALIBRATE_TWO_POINT_SECOND; calibSolutionIndex = 0; menuPressed = false;
    }
}

void handleCalibrateTwoPointSecond() {
    if (upPressed) { do { calibSolutionIndex = (calibSolutionIndex - 1 + 3) % 3; } while (calibSolutionIndex == selectedCalibPoint); upPressed = false; }
    else if (downPressed) { do { calibSolutionIndex = (calibSolutionIndex + 1) % 3; } while (calibSolutionIndex == selectedCalibPoint); downPressed = false; }
    else if (menuPressed) {
        lcd.clear(); lcd.print("Mergulhe a sonda"); lcd.setCursor(0, 1);
        lcd.print("na solucao ");
        switch (calibSolutionIndex) { case 0: lcd.print("4.01"); break; case 1: lcd.print("7.01"); break; case 2: lcd.print("10.01"); break; }
        waitForMenuConfirm();
        lcd.clear(); lcd.print("CALIBRANDO...");
        float sum = 0;
        for (int i = 0; i < PH_READING_COUNT; i++) {
            int analogValue = analogRead(pHPin); float voltage = analogValue * (ADC_REF / ADC_MAX); sum += voltage;
            lcd.setCursor(0, 1); lcd.print("Leitura " + String(i + 1) + "/" + String(PH_READING_COUNT) + "   ");
            lcd.setCursor(0, 2); lcd.print("Tensao: " + String(voltage, 3) + "V   ");
            delay(250);
        }
        float secondCalibValue = sum / 10.0;
        float targetpH1 = 0, targetpH2 = 0;
        switch (selectedCalibPoint) { case 0: targetpH1 = calibpH4; break; case 1: targetpH1 = calibpH7; break; case 2: targetpH1 = calibpH10; break; }
        switch (calibSolutionIndex) { case 0: targetpH2 = calibpH4; break; case 1: targetpH2 = calibpH7; break; case 2: targetpH2 = calibpH10; break; }
        float denom = (targetpH2 - targetpH1);
        if (fabs(denom) < 1e-6) {
            lcd.clear(); lcd.print("Erro: pontos iguais "); delay(1500);
        } else {
            float newSlope = (secondCalibValue - firstCalibValue) / denom;
            if (newSlope > -0.040 || newSlope < -0.080) {
                lcd.clear(); lcd.print("Erro de Calibracao"); lcd.setCursor(0, 1); lcd.print("Slope invalido!"); delay(3000);
            } else {
                pHSlope = newSlope; pHOffset = firstCalibValue - (pHSlope * targetpH1); saveSettings();
                lcd.clear(); lcd.print("Calibracao"); lcd.setCursor(0, 1); lcd.print("Concluida!"); delay(1500);
            }
        }
        currentState = MAIN; menuPressed = false;
    }
}

void controlPump() {
  if (averagePH() < pHIdeal - 0.3) {
    pHBelowIdeal = true;
    digitalWrite(ledPin, HIGH);
    if (pumpActive) {
      digitalWrite(pumpPin, LOW);
      pumpActive = false;
      waitingAfterPump = true;
      lastPumpTime = millis();
    }
    return;
  } else {
    pHBelowIdeal = false;
    digitalWrite(ledPin, LOW);
  }
  if (!isPHStable()) return;
  float phAvg = averagePH();
  if (phAvg > pHIdeal + 0.3 && !waitingAfterPump && !pumpActive) {
    pumpActive = true;
    digitalWrite(pumpPin, HIGH);
    lastPumpTime = millis();
  }
  if (pumpActive && millis() - lastPumpTime >= pumpDuration) {
    digitalWrite(pumpPin, LOW);
    pumpActive = false;
    waitingAfterPump = true;
    lastPumpTime = millis();
  }
  if (waitingAfterPump && millis() - lastPumpTime >= waitAfterPump) {
    waitingAfterPump = false;
  }
}

float averagePH() {
  float sortedReadings[PH_READING_COUNT];
  for (int i = 0; i < PH_READING_COUNT; i++) sortedReadings[i] = pHReadings[i];
  for (int i = 0; i < PH_READING_COUNT - 1; i++) {
    for (int j = 0; j < PH_READING_COUNT - i - 1; j++) {
      if (sortedReadings[j] > sortedReadings[j + 1]) {
        float temp = sortedReadings[j];
        sortedReadings[j] = sortedReadings[j + 1];
        sortedReadings[j + 1] = temp;
      }
    }
  }
  float sum = 0;
  for (int i = 2; i < PH_READING_COUNT - 2; i++) sum += sortedReadings[i];
  return sum / (PH_READING_COUNT - 4);
}

bool isPHStable() {
  float minVal = pHReadings[0];
  float maxVal = pHReadings[0];
  for (int i = 1; i < PH_READING_COUNT; i++) {
    if (pHReadings[i] < minVal) minVal = pHReadings[i];
    if (pHReadings[i] > maxVal) maxVal = pHReadings[i];
  }
  return (maxVal - minVal) <= 0.2;
}

void pHStabilityCheck() {}

void loadSettings() {
  EEPROM.get(PH_IDEAL_ADDR, pHIdeal);
  EEPROM.get(PH_OFFSET_ADDR, pHOffset);
  EEPROM.get(PH_SLOPE_ADDR, pHSlope);
  if (isnan(pHIdeal) || pHIdeal < 0 || pHIdeal > 14) pHIdeal = 6.0;
  if (isnan(pHOffset)) pHOffset = 0.0;
  if (isnan(pHSlope) || pHSlope <= 0) pHSlope = 1.0;
}

void saveSettings() {
  float temp;
  EEPROM.get(PH_IDEAL_ADDR, temp);
  if (temp != pHIdeal) EEPROM.put(PH_IDEAL_ADDR, pHIdeal);
  EEPROM.get(PH_OFFSET_ADDR, temp);
  if (temp != pHOffset) EEPROM.put(PH_OFFSET_ADDR, pHOffset);
  EEPROM.get(PH_SLOPE_ADDR, temp);
  if (temp != pHSlope) EEPROM.put(PH_SLOPE_ADDR, pHSlope);
}
