/*
  ================================================================================================
  == FIRMWARE DE CONTROLE DE PH - VERSÃO PROFISSIONAL 5.0 OTIMIZADA                            ==
  ================================================================================================
  Autor: Jules
  Data da Versão: 2024-09-25

  Descrição:
  Este firmware oferece um controle robusto e preciso do pH para sistemas automatizados.
  Versão otimizada com as correções de segurança e simplificação da configuração de hardware.

  Funcionalidades Chave:
  - Leitura de pH e Temperatura: Utiliza um conversor ADC externo ADS1115 de alta precisão
    para o pH e um sensor DS18B20 para a temperatura.
  - Calibração Inteligente: O processo de calibração de 2 pontos detecta slopes (sensibilidades)
    incomuns e permite que um técnico force a calibração, tornando o sistema compatível com
    uma vasta gama de sensores.
  - Compensação por Temperatura: Todas as leituras de pH são compensadas em tempo real com
    base na temperatura da solução. A calibração também leva a temperatura em conta para
    máxima precisão.
  - Menu Técnico Avançado: Um menu protegido permite o diagnóstico da sonda e o ajuste
    dos limites de slope aceitáveis, que são salvos na memória.
  - Segurança e Robustez: Inclui um Watchdog Timer para prevenir travamentos, validação
    de faixa para as leituras de pH e um sistema seguro de carregamento de configurações.

*/

// --- Bibliotecas ---
#include <Wire.h> // Essencial para comunicação I2C (LCD e ADS1115)
#include <LiquidCrystal_I2C.h> // Controla o display LCD
#include <OneWire.h>           // Protocolo para o sensor de temperatura DS18B20
#include <DallasTemperature.h> // Biblioteca para o sensor DS18B20
#include <EEPROM.h>            // Para salvar as configurações na memória permanente
#include <avr/wdt.h>           // Para o Watchdog Timer
#include <Adafruit_ADS1X15.h>  // Para o conversor ADC externo

// ================================================================================================
// == SEÇÃO DE CONFIGURAÇÕES DE HARDWARE E CONSTANTES                                            ==
// ================================================================================================

// --- Objetos de Hardware ---
LiquidCrystal_I2C lcd(0x27, 20, 4); // Inicializa o LCD no endereço I2C 0x27, com 20 colunas e 4 linhas.
Adafruit_ADS1115 ads;               // Inicializa o objeto para o conversor ADC ADS1115.

// --- Pinos do Arduino ---
#define ONE_WIRE_BUS 2 // O sensor de temperatura DS18B20 está conectado ao pino digital 2.
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);
const int upButton = 3, downButton = 4, menuButton = 5, pumpPin = 6, ledPin = 7; // Pinos dos botões e atuadores.

// --- Constantes de Calibração e Operação ---
const float TEMP_OFFSET_CELSIUS = 0.6; // (AJUSTÁVEL) Offset para calibrar o sensor de temperatura.
const float KELVIN_25 = 298.15;        // Temperatura de referência (25°C) em Kelvin, para cálculos de pH.
const int PH_READING_COUNT = 30;       // Tamanho do buffer de leituras de pH para calcular a média.
const int CALIBRATION_READING_SECONDS = 30; // Duração da leitura para calibração.
const unsigned long pumpDuration = 10000;    // Duração que a bomba fica ligada (em milissegundos).
const unsigned long waitAfterPump = 300000;  // Intervalo de espera após a bomba ser desligada (em ms).
const unsigned long timeout = 30000;         // Timeout para sair dos menus de configuração (em ms).
const unsigned long startupTime = 15000;     // Tempo de estabilização inicial do sistema (em ms).

// --- Valores Padrão para Configurações (Carregados se a EEPROM estiver vazia) ---
const float DEFAULT_PH_IDEAL = 6.5;      // pH ideal padrão para a solução.
const float DEFAULT_PH_OFFSET = 2.8;     // (AJUSTÁVEL) Tensão de referência em pH 7, baseada no seu sensor.
const float DEFAULT_PH_SLOPE = -0.057;   // Sensibilidade padrão de uma sonda (em V/pH a 25°C).
const float DEFAULT_MIN_SLOPE = -0.200;  // (AJUSTÁVEL) Limite mínimo de slope aceitável no Menu Técnico.
const float DEFAULT_MAX_SLOPE = -0.040;  // (AJUSTÁVEL) Limite máximo de slope aceitável no Menu Técnico.

// --- Valores de pH para as Soluções de Calibração ---
const float calibpH4 = 4.01, calibpH7 = 7.01, calibpH10 = 10.01;

// ================================================================================================
// == SEÇÃO DE ESTRUTURAS DE DADOS E VARIÁVEIS GLOBAIS                                           ==
// ================================================================================================

// --- Estruturas e Enums ---
// Estrutura que armazena todas as configurações salvas na memória permanente (EEPROM)
struct Settings {
  float pHIdeal;
  float pHOffset;
  float pHSlope;
  float minSlope; // Limite mínimo aceitável para o slope da sonda
  float maxSlope; // Limite máximo aceitável para o slope da sonda
  uint16_t checksum;
};
Settings settings; // Variável global que mantém as configurações atuais do sistema.

// Todos os estados (telas/modos) possíveis do sistema
enum State {
  STARTUP, MAIN, MENU,
  ADJUST_PH,
  CALIBRATE_MENU, CALIBRATE_ONE_POINT, CALIBRATE_TWO_POINT_FIRST, CALIBRATE_TWO_POINT_SECOND, CALIBRATION_CONFIRM_SLOPE,
  TECH_MENU, SENSOR_DIAGNOSTIC, ADJUST_SLOPE_LIMITS,
  INITIAL_CALIBRATION_PROMPT, SENSOR_ERROR
};
State currentState = STARTUP; // Estado inicial do sistema.
enum ButtonPress { BTN_NONE, BTN_UP, BTN_DOWN, BTN_MENU }; // Tipos de pressionamento de botão.

// --- Variáveis de Controle de Estado e Tempo ---
unsigned long startupEntryTime = 0, lastButtonPress = 0, lastPumpTime = 0, lastPhReadTime = 0, lastTempReadTime = 0;
float pHReadings[PH_READING_COUNT]; // Array para armazenar as últimas leituras de pH para média.
float temperature = 25.0;           // Armazena a última temperatura lida.
float pHValue = 7.0;                // Armazena o último valor de pH instantâneo calculado.
int readingIndex = 0, menuIndex = 0, calibMenuIndex = 0, calibSolutionIndex = 0, selectedCalibPoint = 0;
bool pumpActive = false, waitingAfterPump = false, pHBelowIdeal = false;
State lastDisplayState = (State)-1; // Usado para saber quando redesenhar o LCD.
float lastDisplayedPH = -999.0, lastDisplayedTemp = -999.0, lastDisplayedPIdeal = -999.0, firstCalibValue = 0;
float tempSlope = 0, tempOffset = 0; // Variáveis globais temporárias para o processo de calibração
int confirmIndex = 0; // Variável para os menus de confirmação (0: Não, 1: Sim)
bool lastAlertState = false;

// ================================================================================================
// == SEÇÃO DE PROTÓTIPOS DE FUNÇÕES                                                             ==
// ================================================================================================
// Declaração de todas as funções para que o compilador saiba que elas existem.

// --- Funções Principais de Operação ---
void loadSettings();
void saveSettings();
void readTemperature();
void readpH();
void updateDisplay();
ButtonPress checkButtons();
void controlPump();
float averagePH();
bool isPHStable();

// --- Funções de Gerenciamento de Estado (Telas e Menus) ---
void handleStartup();
void handleMain(ButtonPress);
void handleMenu(ButtonPress);
void handleAdjustPH(ButtonPress);
void handleCalibrateMenu(ButtonPress);
void handleCalibrateOnePoint(ButtonPress);
void handleCalibrateTwoPointFirst(ButtonPress);
void handleCalibrateTwoPointSecond(ButtonPress);
void handleInitialCalibrationPrompt(ButtonPress);
void handleCalibrationConfirmSlope(ButtonPress);
void handleTechMenu(ButtonPress);
void handleSensorDiagnostic();
void handleAdjustSlopeLimits(ButtonPress);

// --- Funções Auxiliares ---
float performStableReading(int seconds);
bool waitForMenuConfirm();
void logError(const char*);
uint16_t calculateChecksum(const Settings&);
bool validateSettings();

// ================================================================================================
// == SEÇÃO DE FUNÇÕES PRINCIPAIS (SETUP E LOOP)                                                 ==
// ================================================================================================

/**
 * @brief Realiza uma série de leituras de tensão para obter um valor médio estável.
 * Usado nos processos de calibração e diagnóstico.
 * @param seconds O número de segundos (e leituras) a serem feitas.
 * @return A tensão média calculada.
 */
float performStableReading(int seconds) {
    float sum = 0;
    for (int i = 0; i < seconds; i++) {
        wdt_reset();
        float volt = ads.computeVolts(ads.readADC_SingleEnded(0));
        sum += volt;
        lcd.setCursor(0, 1); lcd.print("Lendo... "); lcd.print(i + 1); lcd.print("/"); lcd.print(seconds); lcd.print("s");
        lcd.setCursor(0, 2); lcd.print("Tensao: "); lcd.print(volt, 4); lcd.print("V ");
        delay(1000);
    }
    return sum / (float)seconds;
}

/**
 * @brief Função de configuração inicial.
 * É executada uma vez quando o Arduino é ligado ou resetado.
 * Inicializa todos os componentes de hardware e carrega as configurações.
 */
void setup() {
  wdt_disable(); // Desabilita o watchdog temporariamente para o setup não ser interrompido.
  Serial.begin(9600); // Inicia a comunicação serial para debug.
  
  // CORREÇÃO APLICADA: Configuração simplificada dos botões (como na Versão 9.0)
  pinMode(upButton, INPUT_PULLUP);
  pinMode(downButton, INPUT_PULLUP);
  pinMode(menuButton, INPUT_PULLUP);
  
  pinMode(pumpPin, OUTPUT); 
  pinMode(ledPin, OUTPUT);
  digitalWrite(pumpPin, LOW); 
  digitalWrite(ledPin, LOW);
  
  lcd.init(); 
  lcd.backlight();
  lcd.print("Iniciando sistema...");

  sensors.begin();
  if (!ads.begin()) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Erro ADS1115!");
    lcd.setCursor(0, 1);
    lcd.print("Verifique conexoes.");
    while (1); // Trava a execução se o sensor não for encontrado
  }
  ads.setGain(GAIN_ONE); // Configura a faixa de leitura para +/- 4.096V

  delay(500);
  loadSettings();
  for (int i = 0; i < PH_READING_COUNT; i++) { pHReadings[i] = settings.pHIdeal; }
  startupEntryTime = millis();
  wdt_enable(WDTO_4S); // Reabilita o watchdog com um timeout de 4 segundos para segurança.
}

/**
 * @brief Loop principal do programa.
 * É executado continuamente. Responsável por ler os sensores,
 * verificar os botões e chamar os handlers de estado apropriados.
 */
void loop() {
  wdt_reset(); // Reseta o watchdog a cada ciclo para evitar reinicializações.

  // Apenas lê os sensores se o sistema estiver em um estado operacional.
  if (currentState != SENSOR_ERROR) {
    if (millis() - lastTempReadTime >= 2000) { lastTempReadTime = millis(); readTemperature(); }
    if (millis() - lastPhReadTime >= 1000) { lastPhReadTime = millis(); readpH(); }
  }

  ButtonPress button = checkButtons(); // Verifica se algum botão foi pressionado.

  // Máquina de estados: chama a função correspondente ao estado atual.
  switch (currentState) {
    case STARTUP: handleStartup(); break;
    case MAIN: handleMain(button); break;
    case MENU: handleMenu(button); break;
    case ADJUST_PH: handleAdjustPH(button); break;
    case CALIBRATE_MENU: handleCalibrateMenu(button); break;
    case CALIBRATE_ONE_POINT: handleCalibrateOnePoint(button); break;
    case CALIBRATE_TWO_POINT_FIRST: handleCalibrateTwoPointFirst(button); break;
    case CALIBRATE_TWO_POINT_SECOND: handleCalibrateTwoPointSecond(button); break;
    case CALIBRATION_CONFIRM_SLOPE: handleCalibrationConfirmSlope(button); break;
    case TECH_MENU: handleTechMenu(button); break;
    case ADJUST_SLOPE_LIMITS: handleAdjustSlopeLimits(button); break;
    case INITIAL_CALIBRATION_PROMPT: handleInitialCalibrationPrompt(button); break;
    case SENSOR_ERROR: break; // Em caso de erro, não faz nada, apenas exibe a tela de erro.
  }
  if (currentState == MAIN) controlPump();
  updateDisplay();
}

// --- Leitura de Sensores ---
void readTemperature() {
  static int errorCount = 0;
  sensors.requestTemperatures();
  float t = sensors.getTempCByIndex(0);
  if (t == DEVICE_DISCONNECTED_C || isnan(t)) {
    errorCount++;
    if (errorCount > 5) { logError("Falha no sensor de Temp!"); currentState = SENSOR_ERROR; }
  } else {
    errorCount = 0;
    if (t > -40 && t < 125) temperature = t + TEMP_OFFSET_CELSIUS;
  }
}

void readpH() {
  // Lê a tensão diretamente do canal 0 do ADS1115
  float voltage = ads.computeVolts(ads.readADC_SingleEnded(0));

  // A verificação de falha agora é feita no setup() com ads.begin()
  // O restante da lógica de cálculo permanece
  if (fabs(settings.pHSlope) < 1e-6) return;
  float tempK = temperature + 273.15;
  float slopeT = settings.pHSlope * (tempK / KELVIN_25);
  if (fabs(slopeT) < 1e-6) return;
  float pHcalc = 7.0 + (voltage - settings.pHOffset) / slopeT;

  if (!isnan(pHcalc) && pHcalc >= 0.0 && pHcalc <= 14.0) {
    pHValue = pHcalc;
    pHReadings[readingIndex] = pHValue;
    readingIndex = (readingIndex + 1) % PH_READING_COUNT;
  } else {
    // Se o valor for inválido (ex: -1, 15), registra o erro mas não atualiza o buffer de leituras.
    // Isso evita que um valor absurdo afete a média ou o controle da bomba.
    logError("Leitura de pH calculada fora da faixa (0-14). Valor: " + String(pHcalc));
  }
}

// --- Lógica de Controle ---
void controlPump() {
  float phAvg = averagePH();

  // Trava de segurança: desliga a bomba se o pH estiver em uma faixa perigosa.
  if (phAvg < 2.0 || phAvg > 12.0) {
    digitalWrite(pumpPin, LOW);
    pumpActive = false;
    logError("pH fora da faixa segura! Bomba desativada.");
    return;
  }

  if (phAvg < settings.pHIdeal - 0.3) {
    pHBelowIdeal = true; 
    digitalWrite(ledPin, HIGH);
    if (pumpActive) { 
      digitalWrite(pumpPin, LOW); 
      pumpActive = false; 
      waitingAfterPump = true; 
      lastPumpTime = millis(); 
    }
    return;
  } else { 
    pHBelowIdeal = false; 
    digitalWrite(ledPin, LOW); 
  }
  
  if (!isPHStable()) return;
  
  // phAvg já foi calculado no início da função
  if (phAvg > settings.pHIdeal + 0.3 && !waitingAfterPump && !pumpActive) { 
    pumpActive = true; 
    digitalWrite(pumpPin, HIGH); 
    lastPumpTime = millis(); 
  }
  if (pumpActive && millis() - lastPumpTime >= pumpDuration) { 
    digitalWrite(pumpPin, LOW); 
    pumpActive = false; 
    waitingAfterPump = true; 
    lastPumpTime = millis(); 
  }
  if (waitingAfterPump && millis() - lastPumpTime >= waitAfterPump) { 
    waitingAfterPump = false; 
  }
}

// ================================================================================================
// == SEÇÃO DE INTERFACE COM O USUÁRIO (DISPLAY E BOTÕES)                                        ==
// ================================================================================================

/**
 * @brief Atualiza o display LCD com base no estado atual do sistema.
 * Para otimizar, a tela só é limpa e redesenhada se o estado (tela) mudou.
 */
void updateDisplay() {
    if (lastDisplayState != currentState) {
        lcd.clear();
        lastDisplayState = currentState;
        // Reseta os valores da última exibição para forçar a atualização completa da tela.
        lastDisplayedPH = -999.0;
        lastDisplayedTemp = -999.0;
        lastDisplayedPIdeal = -999.0;
        lastAlertState = !pHBelowIdeal;
    }
    switch (currentState) {
        case STARTUP: 
            lcd.setCursor(0, 1); 
            lcd.print("Estabilizando..."); 
            break;
            
        case SENSOR_ERROR: 
            lcd.setCursor(0, 0); 
            lcd.print("ERRO DE SENSOR!"); 
            lcd.setCursor(0, 1); 
            lcd.print("Verifique conexoes."); 
            lcd.setCursor(0, 2); 
            lcd.print("Sistema reiniciara"); 
            lcd.setCursor(0, 3); 
            lcd.print("em breve..."); 
            break;
            
        case MAIN: {
            bool alertStateChanged = lastAlertState != pHBelowIdeal;
            if (alertStateChanged) { 
                lcd.clear(); 
                lastAlertState = pHBelowIdeal; 
                lastDisplayedPH = -999.0; 
            }
            if (pHBelowIdeal) { 
                lcd.setCursor(0, 0); 
                lcd.print("** ALERTA: PH BAIXO **"); 
            } else { 
                const char spinner[] = {'|', '/', '-', '\\'}; 
                char indicator = spinner[readingIndex % 4]; 
                lcd.setCursor(0, 0); 
                lcd.print("STATUS ATUAL "); 
                lcd.print(indicator); 
            }
            float currentAveragePH = averagePH();
            if (fabs(lastDisplayedPH - currentAveragePH) > 0.05 || 
                fabs(lastDisplayedTemp - temperature) > 0.2 || 
                fabs(lastDisplayedPIdeal - settings.pHIdeal) > 0.05 || 
                alertStateChanged) {
                lcd.setCursor(0, 1); 
                lcd.print("PH Medio: "); 
                lcd.print(currentAveragePH, 2); 
                lcd.print("   ");
                lcd.setCursor(0, 2); 
                lcd.print("PH Inst.: "); 
                lcd.print(pHValue, 2); 
                lcd.print("   ");
                lcd.setCursor(0, 3); 
                lcd.print("T:"); 
                lcd.print(temperature, 1); 
                lcd.print((char)223); 
                lcd.print("C "); 
                lcd.print("Ideal:"); 
                lcd.print(settings.pHIdeal, 1); 
                lcd.print("   ");
                lastDisplayedPH = currentAveragePH; 
                lastDisplayedTemp = temperature; 
                lastDisplayedPIdeal = settings.pHIdeal;
            }
            break;
        }
        case MENU:
            lcd.setCursor(0, 0); 
            lcd.print("MENU PRINCIPAL");
            lcd.setCursor(0, 1); 
            lcd.print(menuIndex == 0 ? "> Ajustar PH Ideal" : "  Ajustar PH Ideal");
            lcd.setCursor(0, 2); 
            lcd.print(menuIndex == 1 ? "> Calibrar Sonda" : "  Calibrar Sonda");
            lcd.setCursor(0, 3); 
            lcd.print(menuIndex == 2 ? "> Voltar" : "  Voltar");
            break;
            
        case ADJUST_PH:
            lcd.setCursor(0, 0); 
            lcd.print("Selecione PH Ideal");
            lcd.setCursor(0, 1); 
            lcd.print("Valor: "); 
            lcd.print(settings.pHIdeal, 2);
            lcd.setCursor(0, 3); 
            lcd.print("MENU para confirmar");
            break;
            
        case CALIBRATE_MENU:
            lcd.setCursor(0, 0); 
            lcd.print("MENU DE CALIBRACAO");
            lcd.setCursor(0, 1); 
            lcd.print(menuIndex == 0 ? "> Calibrar: 1 Ponto" : "  Calibrar: 1 Ponto");
            lcd.setCursor(0, 2); 
            lcd.print(menuIndex == 1 ? "> Calibrar: 2 Pontos" : "  Calibrar: 2 Pontos");
            lcd.setCursor(0, 3); 
            lcd.print(menuIndex == 2 ? "> Voltar" : "  Voltar");
            break;
            
        case TECH_MENU:
            lcd.setCursor(0, 0); 
            lcd.print("MENU TECNICO");
            lcd.setCursor(0, 1); 
            lcd.print(menuIndex == 0 ? "> Diagnostico Sonda" : "  Diagnostico Sonda");
            lcd.setCursor(0, 2); 
            lcd.print(menuIndex == 1 ? "> Limites de Slope" : "  Limites de Slope");
            lcd.setCursor(0, 3); 
            lcd.print(menuIndex == 2 ? "> Voltar" : "  Voltar");
            break;
            
        case CALIBRATION_CONFIRM_SLOPE:
            lcd.setCursor(0, 0); 
            lcd.print("Slope fora do padrao");
            lcd.setCursor(0, 1); 
            lcd.print("Medido: "); 
            lcd.print(tempSlope, 4);
            lcd.setCursor(0, 2); 
            lcd.print("Aceitar? > ");
            lcd.print(confirmIndex == 0 ? "Nao" : "Sim");
            break;
            
        case INITIAL_CALIBRATION_PROMPT:
            lcd.setCursor(0, 0); 
            lcd.print("Calibrar sensor?");
            lcd.setCursor(0, 1); 
            lcd.print(calibMenuIndex == 0 ? "> Um Ponto" : "  Um Ponto");
            lcd.setCursor(0, 2); 
            lcd.print(calibMenuIndex == 1 ? "> Dois Pontos" : "  Dois Pontos");
            lcd.setCursor(0, 3); 
            lcd.print(calibMenuIndex == 2 ? "> Ignorar" : "  Ignorar");
            break;
    }
}

/**
 * @brief Verifica o estado dos botões.
 * Inclui lógica de debounce para evitar múltiplas leituras de um único aperto.
 * Também gerencia o acesso ao Menu Técnico com um toque longo.
 * @return O botão que foi pressionado (BTN_UP, BTN_DOWN, BTN_MENU) ou BTN_NONE.
 */
ButtonPress checkButtons() {
    // CORREÇÃO APLICADA: Lógica simplificada - botões usam PULL-UP (ativo em LOW)
    static unsigned long lastPressTime = 0; // Para o debounce
    const unsigned long DEBOUNCE_MS = 200;
    
    if (millis() - lastPressTime > DEBOUNCE_MS) {
        if (digitalRead(upButton) == LOW) { 
            lastPressTime = millis(); 
            return BTN_UP; 
        }
        if (digitalRead(downButton) == LOW) { 
            lastPressTime = millis(); 
            return BTN_DOWN; 
        }
        if (digitalRead(menuButton) == LOW) { 
            lastPressTime = millis(); 
            lastButtonPress = millis(); 
            return BTN_MENU; 
        }
    }
    
    if (currentState != MAIN && currentState != SENSOR_ERROR && millis() - lastButtonPress > timeout) { 
        currentState = MAIN; 
    }
    return BTN_NONE;
}

// ================================================================================================
// == SEÇÃO DE GERENCIAMENTO DE ESTADOS (HANDLERS)                                               ==
// ================================================================================================
// Cada função 'handle' é responsável pela lógica de uma tela ou menu específico.

/** @brief Gerencia a tela de inicialização. */
void handleStartup() { 
    if (millis() - startupEntryTime > startupTime) { 
        if (EEPROM.read(0) != 123) { 
            currentState = INITIAL_CALIBRATION_PROMPT; 
            EEPROM.write(0, 123); 
        } else { 
            currentState = MAIN; 
        } 
    } 
}

/** @brief Gerencia a tela principal, incluindo o acesso ao menu principal e ao menu técnico. */
void handleMain(ButtonPress b) {
    static unsigned long menuButtonPressTime = 0; // Armazena o tempo que o botão de menu foi pressionado.
    if (b == BTN_MENU) {
        menuButtonPressTime = millis();
    }
    if (digitalRead(menuButton) == LOW && menuButtonPressTime > 0) {
        if (millis() - menuButtonPressTime > 2000) { // Se o botão for segurado por 2s
            currentState = TECH_MENU;
            menuButtonPressTime = 0;
        }
    } else {
        if (b == BTN_MENU) {
            currentState = MENU;
        }
        menuButtonPressTime = 0;
    }
}

void handleMenu(ButtonPress b) {
    if (b == BTN_UP) menuIndex = (menuIndex - 1 + 3) % 3;
    else if (b == BTN_DOWN) menuIndex = (menuIndex + 1) % 3;
    else if (b == BTN_MENU) {
        switch (menuIndex) {
            case 0: currentState = ADJUST_PH; break;
            case 1: currentState = CALIBRATE_MENU; menuIndex = 0; break;
            case 2: currentState = MAIN; menuIndex = 0; break;
        }
    }
}

void handleAdjustPH(ButtonPress b) { 
    if (b == BTN_UP) settings.pHIdeal += 0.1; 
    else if (b == BTN_DOWN) settings.pHIdeal -= 0.1; 
    else if (b == BTN_MENU) { 
        saveSettings(); 
        currentState = MAIN; 
    } 
    if (settings.pHIdeal > 14.0) settings.pHIdeal = 14.0; 
    if (settings.pHIdeal < 0.0) settings.pHIdeal = 0.0; 
}

void handleCalibrateMenu(ButtonPress b) {
    if (b == BTN_UP) menuIndex = (menuIndex - 1 + 3) % 3;
    else if (b == BTN_DOWN) menuIndex = (menuIndex + 1) % 3;
    else if (b == BTN_MENU) {
        switch (menuIndex) {
            case 0: currentState = CALIBRATE_ONE_POINT; break;
            case 1: currentState = CALIBRATE_TWO_POINT_FIRST; break;
            case 2: currentState = MAIN; menuIndex = 0; break;
        }
    }
}

void handleInitialCalibrationPrompt(ButtonPress b) { 
    if (b == BTN_UP) calibMenuIndex = (calibMenuIndex - 1 + 3) % 3; 
    else if (b == BTN_DOWN) calibMenuIndex = (calibMenuIndex + 1) % 3; 
    else if (b == BTN_MENU) { 
        switch (calibMenuIndex) { 
            case 0: currentState = CALIBRATE_ONE_POINT; break; 
            case 1: currentState = CALIBRATE_TWO_POINT_FIRST; break; 
            case 2: currentState = MAIN; break; 
        } 
    } 
}

void handleCalibrationConfirmSlope(ButtonPress b) {
    // CORREÇÃO: Usa a variável global confirmIndex corretamente
    if (b == BTN_UP || b == BTN_DOWN) {
        confirmIndex = !confirmIndex;
    }
    if (b == BTN_MENU) {
        if (confirmIndex == 1) { // Se "Sim" for selecionado
            settings.pHSlope = tempSlope;
            settings.pHOffset = tempOffset;
            saveSettings();
            lcd.clear(); 
            lcd.print("Calibracao Forcada"); 
            lcd.setCursor(0, 1); 
            lcd.print("Concluida!"); 
            delay(1500);
        } else {
            lcd.clear(); 
            lcd.print("Calibracao"); 
            lcd.setCursor(0, 1); 
            lcd.print("Cancelada."); 
            delay(1500);
        }
        currentState = MAIN;
        confirmIndex = 0; // Reset para próxima vez
        menuIndex = 0;    // Reset do menu principal
    }
}

/**
 * @brief Gerencia a tela e a lógica para o diagnóstico da sonda de pH.
 * Guia o técnico a medir as tensões em pH 7 e pH 4 e exibe o slope calculado.
 * Não salva nenhuma configuração, serve apenas para análise.
 */
void handleSensorDiagnostic() {
    // CORREÇÃO: Declaração correta das variáveis
    // Medição no Ponto 1 (pH 7)
    lcd.clear();
    lcd.print("DIAGNOSTICO: PONTO 1");
    lcd.setCursor(0, 1);
    lcd.print("Mergulhe em pH 7.01");
    waitForMenuConfirm();
    lcd.clear();
    lcd.print("Lendo tensao...");
    float v_ph7 = performStableReading(30);

    // Medição no Ponto 2 (pH 4)
    lcd.clear();
    lcd.print("DIAGNOSTICO: PONTO 2");
    lcd.setCursor(0, 1);
    lcd.print("Lave e mergulhe em");
    lcd.setCursor(0, 2);
    lcd.print("pH 4.01");
    waitForMenuConfirm();
    lcd.clear();
    lcd.print("Lendo tensao...");
    float v_ph4 = performStableReading(30);

    // Cálculo e Exibição do Resultado
    readTemperature();
    float tempK = temperature + 273.15;
    float tempFactor = tempK / KELVIN_25;
    float slope_diagnostic = (v_ph4 - v_ph7) / (calibpH4 - calibpH7);
    float slope_normalized = slope_diagnostic / tempFactor;

    lcd.clear();
    lcd.print("Diagnostico Finalizado");
    lcd.setCursor(0, 1);
    lcd.print("Slope Medido: ");
    lcd.setCursor(0, 2);
    lcd.print(slope_normalized, 4);
    lcd.setCursor(0, 3);
    lcd.print("Pressione MENU...");

    while(checkButtons() != BTN_MENU) {
        wdt_reset();
    }

    currentState = TECH_MENU;
}

/**
 * @brief Gerencia a tela e a lógica para ajustar os limites de slope.
 * Permite que o técnico modifique e salve os valores de slope mínimo e máximo aceitáveis.
 */
void handleAdjustSlopeLimits(ButtonPress b) {
    static int slopeMenuIndex = 0; // 0: Min, 1: Max, 2: Salvar
    static bool editing = false;

    if (editing) {
        if (slopeMenuIndex == 0) { // Editando Min Slope
            if (b == BTN_UP) settings.minSlope -= 0.001;
            if (b == BTN_DOWN) settings.minSlope += 0.001;
        } else { // Editando Max Slope
            if (b == BTN_UP) settings.maxSlope -= 0.001;
            if (b == BTN_DOWN) settings.maxSlope += 0.001;
        }
        if (b == BTN_MENU) {
            editing = false;
        }
    } else {
        if (b == BTN_UP) slopeMenuIndex = (slopeMenuIndex - 1 + 3) % 3;
        if (b == BTN_DOWN) slopeMenuIndex = (slopeMenuIndex + 1) % 3;
        if (b == BTN_MENU) {
            if (slopeMenuIndex < 2) {
                editing = true;
            } else {
                saveSettings();
                lcd.clear();
                lcd.print("Limites Salvos!");
                delay(1500);
                currentState = TECH_MENU;
            }
        }
    }

    // Lógica de Display para esta tela
    lcd.setCursor(0, 0); 
    lcd.print("AJUSTAR LIMITES SLOPE");

    // Min Slope
    lcd.setCursor(0, 1);
    if (slopeMenuIndex == 0) lcd.print(editing ? ">>" : "> "); else lcd.print("  ");
    lcd.print("Min: "); lcd.print(settings.minSlope, 4);

    // Max Slope
    lcd.setCursor(0, 2);
    if (slopeMenuIndex == 1) lcd.print(editing ? ">>" : "> "); else lcd.print("  ");
    lcd.print("Max: "); lcd.print(settings.maxSlope, 4);

    // Salvar
    lcd.setCursor(0, 3);
    if (slopeMenuIndex == 2) lcd.print("> "); else lcd.print("  ");
    lcd.print("Salvar e Sair");
}

void handleTechMenu(ButtonPress b) {
    if (b == BTN_UP) menuIndex = (menuIndex - 1 + 3) % 3;
    else if (b == BTN_DOWN) menuIndex = (menuIndex + 1) % 3;
    else if (b == BTN_MENU) {
        switch (menuIndex) {
            case 0: handleSensorDiagnostic(); break;
            case 1: currentState = ADJUST_SLOPE_LIMITS; break;
            case 2: currentState = MAIN; menuIndex = 0; break;
        }
    }
}

bool waitForMenuConfirm() { 
    lcd.setCursor(0, 2); 
    lcd.print("Press MENU quando "); 
    lcd.setCursor(0, 3); 
    lcd.print("pronto             "); 
    while (true) { 
        wdt_reset(); 
        if (checkButtons() == BTN_MENU) { 
            delay(120); 
            return true; 
        } 
        delay(80); 
    } 
}

void handleCalibrateOnePoint(ButtonPress b) {
    lcd.setCursor(0, 0); 
    lcd.print("CALIBRAR: 1 PONTO  "); 
    lcd.setCursor(0, 1); 
    lcd.print(calibSolutionIndex == 0 ? "> Solucao 4.01" : "  Solucao 4.01"); 
    lcd.setCursor(0, 2); 
    lcd.print(calibSolutionIndex == 1 ? "> Solucao 7.01" : "  Solucao 7.01"); 
    lcd.setCursor(0, 3); 
    lcd.print(calibSolutionIndex == 2 ? "> Solucao 10.01" : "  Solucao 10.01");
    
    if (b == BTN_UP) calibSolutionIndex = (calibSolutionIndex - 1 + 3) % 3; 
    else if (b == BTN_DOWN) calibSolutionIndex = (calibSolutionIndex + 1) % 3; 
    else if (b == BTN_MENU) {
        lcd.clear(); 
        lcd.print("Mergulhe a sonda"); 
        lcd.setCursor(0, 1); 
        lcd.print("na solucao e espere"); 
        waitForMenuConfirm(); 
        lcd.clear(); 
        lcd.print("CALIBRANDO...");
        float avgVoltage = performStableReading(CALIBRATION_READING_SECONDS);
        readTemperature(); // Garante que a temperatura está atualizada
        float targetpH = 0;
        switch (calibSolutionIndex) { 
            case 0: targetpH = calibpH4; break; 
            case 1: targetpH = calibpH7; break; 
            case 2: targetpH = calibpH10; break; 
        }
        if (fabs(settings.pHSlope) < 1e-6) { 
            logError("Slope invalido, calibre com 2 pontos."); 
            lcd.clear(); 
            lcd.print("Slope invalido."); 
            lcd.setCursor(0,1); 
            lcd.print("Faca 2 pontos"); 
            delay(2500); 
        } else {
            float tempK = temperature + 273.15;
            float slopeT = settings.pHSlope * (tempK / KELVIN_25);
            settings.pHOffset = avgVoltage - (slopeT * (targetpH - 7.0));
            saveSettings();
            lcd.clear(); 
            lcd.print("Calibracao"); 
            lcd.setCursor(0, 1); 
            lcd.print("Concluida!"); 
            delay(1500);
        }
        currentState = MAIN;
        menuIndex = 0; // Reset do menu
    }
}

void handleCalibrateTwoPointFirst(ButtonPress b) {
    lcd.setCursor(0, 0); 
    lcd.print("CALIBRAR: PONTO 1/2"); 
    lcd.setCursor(0, 1); 
    lcd.print(calibSolutionIndex == 0 ? "> Solucao 4.01" : "  Solucao 4.01"); 
    lcd.setCursor(0, 2); 
    lcd.print(calibSolutionIndex == 1 ? "> Solucao 7.01" : "  Solucao 7.01"); 
    lcd.setCursor(0, 3); 
    lcd.print(calibSolutionIndex == 2 ? "> Solucao 10.01" : "  Solucao 10.01");
    
    if (b == BTN_UP) calibSolutionIndex = (calibSolutionIndex - 1 + 3) % 3; 
    else if (b == BTN_DOWN) calibSolutionIndex = (calibSolutionIndex + 1) % 3; 
    else if (b == BTN_MENU) {
        selectedCalibPoint = calibSolutionIndex;
        lcd.clear(); 
        lcd.print("Mergulhe a sonda"); 
        lcd.setCursor(0, 1); 
        lcd.print("na solucao e espere"); 
        waitForMenuConfirm(); 
        lcd.clear(); 
        lcd.print("CALIBRANDO...");
        firstCalibValue = performStableReading(CALIBRATION_READING_SECONDS);
        lcd.clear(); 
        lcd.print("Primeiro ponto"); 
        lcd.setCursor(0, 1); 
        lcd.print("calibrado!"); 
        delay(1200);
        currentState = CALIBRATE_TWO_POINT_SECOND; 
        calibSolutionIndex = (selectedCalibPoint + 1) % 3;
    }
}

void handleCalibrateTwoPointSecond(ButtonPress b) {
    lcd.setCursor(0, 0); 
    lcd.print("CALIBRAR: PONTO 2/2");
    
    if (b == BTN_UP) { 
        do { 
            calibSolutionIndex = (calibSolutionIndex - 1 + 3) % 3; 
        } while (calibSolutionIndex == selectedCalibPoint); 
    } else if (b == BTN_DOWN) { 
        do { 
            calibSolutionIndex = (calibSolutionIndex + 1) % 3; 
        } while (calibSolutionIndex == selectedCalibPoint); 
    }
    
    lcd.setCursor(0, 1); 
    lcd.print((calibSolutionIndex == 0 && selectedCalibPoint != 0) ? "> Solucao 4.01" : "  Solucao 4.01");
    lcd.setCursor(0, 2); 
    lcd.print((calibSolutionIndex == 1 && selectedCalibPoint != 1) ? "> Solucao 7.01" : "  Solucao 7.01");
    lcd.setCursor(0, 3); 
    lcd.print((calibSolutionIndex == 2 && selectedCalibPoint != 2) ? "> Solucao 10.01" : "  Solucao 10.01");
    
    if (b == BTN_MENU) {
        lcd.clear(); 
        lcd.print("Mergulhe a sonda"); 
        lcd.setCursor(0, 1); 
        lcd.print("na solucao e espere"); 
        waitForMenuConfirm(); 
        lcd.clear(); 
        lcd.print("CALIBRANDO...");
        float secondCalibValue = performStableReading(CALIBRATION_READING_SECONDS);
        float targetpH1 = 0, targetpH2 = 0;
        switch (selectedCalibPoint) { 
            case 0: targetpH1 = calibpH4; break; 
            case 1: targetpH1 = calibpH7; break; 
            case 2: targetpH1 = calibpH10; break; 
        }
        switch (calibSolutionIndex) { 
            case 0: targetpH2 = calibpH4; break; 
            case 1: targetpH2 = calibpH7; break; 
            case 2: targetpH2 = calibpH10; break; 
        }
        float denom = (targetpH2 - targetpH1);
        if (fabs(denom) < 1e-6) { 
            logError("Calibracao 2 pontos: pontos iguais."); 
            lcd.clear(); 
            lcd.print("Erro: pontos iguais "); 
            delay(1500); 
        } else {
            readTemperature(); // Garante que a temperatura está atualizada
            float tempK = temperature + 273.15;
            float tempFactor = tempK / KELVIN_25;

            float newSlope = (secondCalibValue - firstCalibValue) / denom;
            float newSlopeNormalized = newSlope / tempFactor;

            // CORREÇÃO: Usa as variáveis globais diretamente, sem redeclarar
            tempSlope = newSlopeNormalized;
            tempOffset = firstCalibValue - (newSlope * (targetpH1 - 7.0));

            if (newSlopeNormalized > settings.maxSlope || newSlopeNormalized < settings.minSlope) {
                // Se o slope estiver fora dos limites, pede a confirmação do técnico
                currentState = CALIBRATION_CONFIRM_SLOPE;
            } else {
                // Se o slope for válido, salva diretamente
                settings.pHSlope = tempSlope;
                settings.pHOffset = tempOffset;
                saveSettings();
                lcd.clear(); 
                lcd.print("Calibracao"); 
                lcd.setCursor(0, 1); 
                lcd.print("Concluida!"); 
                delay(1500);
                currentState = MAIN;
                menuIndex = 0; // Reset do menu
            }
        }
    }
}

// ================================================================================================
// == SEÇÃO DE FUNÇÕES AUXILIARES                                                                ==
// ================================================================================================

/**
 * @brief Calcula a média das leituras de pH, descartando os valores mais altos e mais baixos.
 * Isso cria uma média mais estável, resistente a leituras anormais momentâneas.
 * @return O valor médio do pH.
 */
float averagePH() { 
    float sorted[PH_READING_COUNT]; 
    for(int i=0;i<PH_READING_COUNT;i++) sorted[i]=pHReadings[i]; 
    for(int i=0;i<PH_READING_COUNT-1;i++) 
        for(int j=0;j<PH_READING_COUNT-i-1;j++) 
            if(sorted[j]>sorted[j+1]){
                float t=sorted[j];
                sorted[j]=sorted[j+1];
                sorted[j+1]=t;
            } 
    float sum=0; 
    for(int i=2;i<PH_READING_COUNT-2;i++) sum+=sorted[i]; 
    return sum/(float)(PH_READING_COUNT-4); 
}

/**
 * @brief Verifica se a leitura de pH está estável.
 * A leitura é considerada estável se a diferença entre o valor máximo e mínimo no buffer for pequena.
 * @return True se a leitura for estável, false caso contrário.
 */
bool isPHStable() { 
    float minVal=pHReadings[0],maxVal=pHReadings[0]; 
    for(int i=1;i<PH_READING_COUNT;i++){
        if(pHReadings[i]<minVal)minVal=pHReadings[i];
        if(pHReadings[i]>maxVal)maxVal=pHReadings[i];
    } 
    return (maxVal-minVal)<=0.2; 
}

/**
 * @brief Calcula um checksum simples para a estrutura de configurações.
 * Usado para verificar a integridade dos dados salvos na EEPROM.
 * @param s A estrutura de configurações.
 * @return O valor do checksum calculado.
 */
uint16_t calculateChecksum(const Settings& s) { 
    uint16_t cs=0; 
    const byte*p=(const byte*)&s; 
    for(size_t i=0;i<sizeof(s)-sizeof(s.checksum);++i) 
        cs+=*p++; 
    return cs; 
}

/**
 * @brief Valida as configurações carregadas da EEPROM.
 * CORREÇÃO MANTIDA: Validação segura que não permite slope zero (evita divisão por zero).
 * @return true se as configurações são válidas, false caso contrário.
 */
bool validateSettings() {
    if (settings.pHIdeal < 0.0 || settings.pHIdeal > 14.0) return false;
    if (settings.minSlope >= settings.maxSlope) return false;
    if (fabs(settings.pHSlope) < 0.001) return false; // CORREÇÃO CRÍTICA MANTIDA: Não permite slope zero
    return true;
}

void loadSettings() {
  EEPROM.get(0, settings);
  // Se o checksum for inválido OU se as configurações forem inválidas, carrega os padrões.
  if (settings.checksum != calculateChecksum(settings) || !validateSettings()) {
    logError("Checksum invalido ou configuracoes invalidas! Carregando padroes.");
    lcd.clear();
    lcd.setCursor(0, 0); lcd.print("CONFIG. INVALIDA");
    lcd.setCursor(0, 1); lcd.print("CARREGANDO PADROES");
    delay(3500);
    lcd.clear();

    settings.pHIdeal = DEFAULT_PH_IDEAL;
    settings.pHOffset = DEFAULT_PH_OFFSET;
    settings.pHSlope = DEFAULT_PH_SLOPE;
    settings.minSlope = DEFAULT_MIN_SLOPE;
    settings.maxSlope = DEFAULT_MAX_SLOPE;
    saveSettings();
  }
}

void saveSettings() {
  settings.checksum = calculateChecksum(settings);
  EEPROM.put(0, settings);
}

void logError(const char* message) {
  Serial.print("ERRO: ");
  Serial.println(message);
}
