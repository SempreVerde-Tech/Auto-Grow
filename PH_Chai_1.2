/*
  CONTROLADOR AUTOMÁTICO DE PH - ARDUINO NANO (ATmega328P)
  Completo: ADS1115, DS18B20, LCD 20x4 I2C, calibragem 1/2 pontos, menu, EEPROM, watchdog.
  Autor: adaptado para Rafa
  Data: 2025-09-29 (versão final entregue)
*/

/*  Bibliotecas necessárias (instalar via Library Manager se faltar):
    - Adafruit_ADS1X15
    - LiquidCrystal_I2C
    - OneWire
    - DallasTemperature
*/

#include <Wire.h>
#include <Adafruit_ADS1X15.h>
#include <LiquidCrystal_I2C.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <EEPROM.h>
#include <avr/wdt.h> // watchdog

// ========================= HARDWARE PINS =========================
#define PIN_DS18B20       2   // D2 -> OneWire data
#define PIN_BTN_MENU      3   // D3 (touch/menu) - INPUT_PULLUP
#define PIN_BTN_DOWN      4   // D4 (touch/down)
#define PIN_BTN_UP        5   // D5 (touch/up)
#define PIN_MOSFET_TRIG   6   // D6 -> ativa MOSFET (bomba)
#define PIN_LED_ALERT     7   // D7 -> LED indicador (pH abaixo do ideal)
#define ANALOG_FALLBACK   A0  // fallback analog read (se ADS não disponível)

// ========================= I2C / DISPLAY / ADC =========================
#define ADS_ADDR_DEFAULT  0x48
#define LCD_ADDRESS       0x27
#define LCD_COLS          20
#define LCD_ROWS          4

// ADS1115 LSB (usando GAIN_ONE => ±4.096V): 4.096 / 32768 = 0.000125 V per count
const float ADS1115_LSB_V = 0.000125f; // V/count

// ========================= OPERAÇÃO / TIMEOUTS / CONSTS =========================
const uint8_t NUM_SAMPLES = 15;
const uint8_t DISCARD_HIGHEST = 2;
const uint8_t DISCARD_LOWEST = 2;
const unsigned long SAMPLE_INTERVAL_MS = 1000UL;        // 1s entre amostras
const unsigned long INACTIVITY_TIMEOUT_MS = 30000UL;    // 30s inatividade (menus)
const unsigned long PUMP_COOLDOWN_MS = 300000UL;        // 5 minutos cooldown entre ativações da bomba
const unsigned long CALIB_SAMPLE_INTERVAL_MS = 1000UL; // 1s entre amostras de calibração
const uint8_t CALIB_MAX_ATTEMPTS = 5;
const float PH_DELTA_ALERT = 0.3f;
const float PH_STABLE_THRESHOLD = 0.1f;

// ========================= EEPROM (struct) =========================
const int EEPROM_ADDR = 0;
const uint32_t EEPROM_MAGIC = 0xA5C0FFEEUL;

struct Config {
  uint32_t magic;
  uint8_t calibType;           // 0 = none, 1 = 1 point, 2 = 2 points
  float slope_mV_per_pH;       // slope (mV per pH) => pH = (mV - offset) / slope
  float offset_mV;             // offset in mV
  float phIdeal;               // target pH (1.0 .. 13.0)
  uint32_t pumpDurationMs;     // pump on duration (ms)
};
Config cfg;

// ========================= OBJECTS =========================
LiquidCrystal_I2C lcd(LCD_ADDRESS, LCD_COLS, LCD_ROWS);
Adafruit_ADS1115 ads; // instanciar sem argumento (lib atual)
OneWire oneWire(PIN_DS18B20);
DallasTemperature ds(&oneWire);

// ========================= RUNTIME VARS =========================
bool adsAvailable = false;

float samples_mV[NUM_SAMPLES];
uint8_t sampleIndex = 0;
bool samplesFilled = false;
unsigned long lastSampleMillis = 0;
unsigned long lastInteractionMillis = 0;
unsigned long lastPumpActivatedMillis = 0;
bool pumpCooldown = false;

float phInst = 7.0f;
float phAtual = 7.0f;
float lastConfirmedPH = 7.0f;

char spinnerChars[] = "|/-\\";
uint8_t spinnerIndex = 0;

// SCREEN STATE
enum Screen { SCR_BOOT, SCR_MONITOR, SCR_MENU_MAIN, SCR_SET_PH, SCR_CALIB_MENU,
              SCR_CALIB_1_SELECT, SCR_CALIB_2_FIRST, SCR_CALIB_2_SECOND,
              SCR_TECH_MENU, SCR_RAW_VALUES, SCR_CHECK_SENSORS,
              SCR_CONFIRM_REBOOT, SCR_ERROR_CALIB };
Screen screen = SCR_BOOT;
unsigned long screenEnteredMillis = 0;
float tempPHSetting = 7.0f;
unsigned long tempPumpSettingMs = 1000UL;

// debounce helpers
unsigned long lastDebounceTimeMenu = 0, lastDebounceTimeDown = 0, lastDebounceTimeUp = 0;
bool lastBtnStateMenu = HIGH, lastBtnStateDown = HIGH, lastBtnStateUp = HIGH;
const unsigned long DEBOUNCE_MS = 30;

// ========================= DECLARATIONS =========================
void loadConfig();
void saveConfig();
float readADSmV_singleEnded();
float readTemperatureC();
float voltageToPH(float voltage_mV, float tempC);
float computeFilteredAverageFromArray(float arr[], uint8_t len);
bool collectCalibAverages_mV(float &avg_mV);
bool calibrateOnePoint(float solutionPH);
bool calibrateTwoPoints(float phA, float phB);
void checkSensorsAndDisplay();
void doRebootNow();
void performPHAdjustmentAction(float currentPH);
bool readButtonPressed(uint8_t pin, bool &lastState, unsigned long &lastDebounceTime);
void lcdPrintCentered(int row, const char *txt);
void drawProgressBar(int row, int col, int width, float percent);

// ========================= IMPLEMENTATION =========================

// Load config from EEPROM (or set defaults)
void loadConfig() {
  EEPROM.get(EEPROM_ADDR, cfg);
  if (cfg.magic != EEPROM_MAGIC) {
    cfg.magic = EEPROM_MAGIC;
    cfg.calibType = 0;
    cfg.slope_mV_per_pH = -59.16f; // theoretical slope at 25°C (mV per pH)
    cfg.offset_mV = 0.0f;
    cfg.phIdeal = 7.0f;
    cfg.pumpDurationMs = 1000UL;
    EEPROM.put(EEPROM_ADDR, cfg);
  }
}

void saveConfig() {
  cfg.magic = EEPROM_MAGIC;
  EEPROM.put(EEPROM_ADDR, cfg);
}

// Read ADS1115 A0 in mV; fallback to analogRead(A0) if ADS not available
float readADSmV_singleEnded() {
  if (adsAvailable) {
    int16_t raw = ads.readADC_SingleEnded(0);
    float volts = raw * ADS1115_LSB_V; // V
    return volts * 1000.0f; // mV
  } else {
    int raw = analogRead(ANALOG_FALLBACK);
    float mV = (raw / 1023.0f) * 5000.0f;
    return mV;
  }
}

// Read temp from DS18B20 (°C)
float readTemperatureC() {
  ds.requestTemperatures();
  float t = ds.getTempCByIndex(0);
  if (t == DEVICE_DISCONNECTED_C) return NAN;
  return t;
}

// Convert mV -> pH using config; fallback to theoretical Nernst if slope is default/zero
float voltageToPH(float voltage_mV, float tempC) {
  if (fabs(cfg.slope_mV_per_pH) > 0.00001f) {
    float ph = (voltage_mV - cfg.offset_mV) / cfg.slope_mV_per_pH;
    return ph;
  } else {
    // theoretical slope (mV/pH) adjusted by temperature: slope25 * (T_K / 298.15)
    float slope25 = -59.16f; // mV/pH at 25°C
    if (isnan(tempC)) tempC = 25.0f;
    float slopeTemp = slope25 * ((tempC + 273.15f) / 298.15f);
    if (fabs(slopeTemp) < 0.00001f) return 7.0f;
    float ph = (voltage_mV - 0.0f) / slopeTemp;
    return ph;
  }
}

// Simple insertion sort + discard extremes average
float computeFilteredAverageFromArray(float arr[], uint8_t len) {
  float tmp[NUM_SAMPLES];
  for (uint8_t i = 0; i < len; i++) tmp[i] = arr[i];
  // insertion sort
  for (uint8_t i = 1; i < len; i++) {
    float key = tmp[i];
    int j = i - 1;
    while (j >= 0 && tmp[j] > key) {
      tmp[j + 1] = tmp[j];
      j--;
      if (j < 0) break;
    }
    tmp[j + 1] = key;
  }
  uint8_t start = DISCARD_LOWEST;
  uint8_t end = len - DISCARD_HIGHEST;
  float sum = 0;
  for (uint8_t i = start; i < end; i++) sum += tmp[i];
  float avg = sum / float(end - start);
  return avg;
}

// UI helpers
void lcdPrintCentered(int row, const char *txt) {
  int len = strlen(txt);
  int pos = max(0, (LCD_COLS - len) / 2);
  lcd.setCursor(pos, row);
  lcd.print(txt);
}
void drawProgressBar(int row, int col, int width, float percent) {
  int filled = int((percent / 100.0f) * width + 0.5f);
  if (filled < 0) filled = 0;
  if (filled > width) filled = width;
  lcd.setCursor(col, row);
  for (int i = 0; i < filled; i++) lcd.print(char(255));
  for (int i = filled; i < width; i++) lcd.print(' ');
}
void showSpinner() {
  lcd.setCursor(0, 0);
  lcd.print("MONITORANDO ");
  lcd.print(spinnerChars[spinnerIndex]);
  spinnerIndex = (spinnerIndex + 1) % 4;
}

// Debounced button read (INPUT_PULLUP, pressed = LOW)
bool readButtonPressed(uint8_t pin, bool &lastState, unsigned long &lastDebounceTime) {
  bool reading = digitalRead(pin);
  if (reading != lastState) {
    lastDebounceTime = millis();
  }
  if ((millis() - lastDebounceTime) > DEBOUNCE_MS) {
    if (reading == LOW && lastState == HIGH) {
      lastState = reading;
      return true;
    }
  }
  lastState = reading;
  return false;
}

// --- Calibration helpers ---
// collect NUM_SAMPLES with CALIB_SAMPLE_INTERVAL_MS interval and return filtered avg in mV
bool collectCalibAverages_mV(float &avg_mV) {
  float localSamples[NUM_SAMPLES];
  for (uint8_t i = 0; i < NUM_SAMPLES; i++) {
    unsigned long sstart = millis();
    while (millis() - sstart < CALIB_SAMPLE_INTERVAL_MS) { wdt_reset(); delay(10); }
    localSamples[i] = readADSmV_singleEnded();
  }
  avg_mV = computeFilteredAverageFromArray(localSamples, NUM_SAMPLES);
  return true;
}

// 1-point calibration: uses theoretical slope adjusted by temp, computes offset
bool calibrateOnePoint(float solutionPH) {
  lcd.clear(); lcdPrintCentered(0, "CALIBRAGEM 1 PONTO");
  lcd.setCursor(0,1); lcd.print("Solução pH: ");
  lcd.print(solutionPH, 2);
  lcd.setCursor(0,2); lcd.print("Insira a sonda");
  lcd.setCursor(0,3); lcd.print("Press MENU quando pronto");

  // wait MENU
  while (true) {
    if (readButtonPressed(PIN_BTN_MENU, lastBtnStateMenu, lastDebounceTimeMenu)) break;
    wdt_reset(); delay(10);
  }

  for (uint8_t attempt = 1; attempt <= CALIB_MAX_ATTEMPTS; attempt++) {
    float avg1 = 0;
    lcd.clear(); lcdPrintCentered(0, "Coletando 15 amostras");
    if (!collectCalibAverages_mV(avg1)) return false;

    float tempC = readTemperatureC();
    if (isnan(tempC)) tempC = 25.0f;
    float slope25 = -59.16f;
    float slopeTemp = slope25 * ((tempC + 273.15f) / 298.15f); // mV/pH
    float offset = avg1 - slopeTemp * solutionPH;

    float avg2 = 0;
    lcd.clear(); lcdPrintCentered(0, "Validando leituras");
    if (!collectCalibAverages_mV(avg2)) return false;

    float ph2 = (avg2 - offset) / slopeTemp;
    float diff = fabs(ph2 - solutionPH);
    if (diff <= 0.1f) {
      cfg.calibType = 1;
      cfg.slope_mV_per_pH = slopeTemp;
      cfg.offset_mV = offset;
      saveConfig();
      lcd.clear(); lcdPrintCentered(1, "Calibragem OK");
      delay(900);
      return true;
    } else {
      lcd.clear();
      lcd.setCursor(0,0); lcd.print("Validação falhou");
      lcd.setCursor(0,1); lcd.print("Dif: "); lcd.print(diff, 3);
      lcd.setCursor(0,2); lcd.print("Tentativa ");
      lcd.print(attempt);
      delay(900);
    }
  }
  return false;
}

// 2-point calibration: collects two points and computes slope & offset; validates with repeats
bool calibrateTwoPoints(float phA, float phB) {
  lcd.clear(); lcdPrintCentered(0, "CALIBRAGEM 2 PONTOS");
  // first point
  lcd.setCursor(0,1); lcd.print("1o pH: "); lcd.print(phA,2);
  lcd.setCursor(0,2); lcd.print("Insira e MENU");
  while (true) { if (readButtonPressed(PIN_BTN_MENU, lastBtnStateMenu, lastDebounceTimeMenu)) break; wdt_reset(); delay(10); }
  float avgA1 = 0; if (!collectCalibAverages_mV(avgA1)) return false;

  // second point
  lcd.clear(); lcd.setCursor(0,1); lcd.print("2o pH: "); lcd.print(phB,2);
  lcd.setCursor(0,2); lcd.print("Insira e MENU");
  while (true) { if (readButtonPressed(PIN_BTN_MENU, lastBtnStateMenu, lastDebounceTimeMenu)) break; wdt_reset(); delay(10); }
  float avgB1 = 0; if (!collectCalibAverages_mV(avgB1)) return false;

  if (fabs(phA - phB) < 0.0001f) return false;
  float slope = (avgA1 - avgB1) / (phA - phB); // mV per pH
  float offset = avgA1 - slope * phA;

  // validation repeats
  for (uint8_t attempt = 1; attempt <= CALIB_MAX_ATTEMPTS; attempt++) {
    // repeat A
    lcd.clear(); lcd.setCursor(0,1); lcd.print("Repita 1o pH: "); lcd.print(phA,2);
    lcd.setCursor(0,2); lcd.print("Press MENU");
    while (true) { if (readButtonPressed(PIN_BTN_MENU, lastBtnStateMenu, lastDebounceTimeMenu)) break; wdt_reset(); delay(10); }
    float avgA2 = 0; if (!collectCalibAverages_mV(avgA2)) return false;

    // repeat B
    lcd.clear(); lcd.setCursor(0,1); lcd.print("Repita 2o pH: "); lcd.print(phB,2);
    lcd.setCursor(0,2); lcd.print("Press MENU");
    while (true) { if (readButtonPressed(PIN_BTN_MENU, lastBtnStateMenu, lastDebounceTimeMenu)) break; wdt_reset(); delay(10); }
    float avgB2 = 0; if (!collectCalibAverages_mV(avgB2)) return false;

    float phA_check = (avgA2 - offset) / slope;
    float phB_check = (avgB2 - offset) / slope;
    float d1 = fabs(phA_check - phA);
    float d2 = fabs(phB_check - phB);
    if (d1 <= 0.1f && d2 <= 0.1f) {
      cfg.calibType = 2;
      cfg.slope_mV_per_pH = slope;
      cfg.offset_mV = offset;
      saveConfig();
      lcd.clear(); lcdPrintCentered(1, "Calib 2P OK");
      delay(900);
      return true;
    } else {
      lcd.clear();
      lcd.setCursor(0,0); lcd.print("Validacao falhou");
      lcd.setCursor(0,1); lcd.print("d1:"); lcd.print(d1,3);
      lcd.setCursor(0,2); lcd.print("d2:"); lcd.print(d2,3);
      delay(900);
    }
  }
  return false;
}

// sensor check screen
void checkSensorsAndDisplay() {
  lcd.clear(); lcdPrintCentered(0, "TESTANDO SENSORES");
  lcd.setCursor(0,1); lcd.print("Aguarde...");
  bool okDS = false, okADS = false, okPH = false;

  ds.requestTemperatures();
  float t = ds.getTempCByIndex(0);
  okDS = (t != DEVICE_DISCONNECTED_C);

  float v = readADSmV_singleEnded();
  okADS = (!isnan(v) && v > -10000 && v < 10000);

  okPH = (v > -1000 && v < 5000);

  lcd.clear();
  lcd.setCursor(0,0); lcd.print("DS18B20: "); lcd.print(okDS ? "OK" : "ERRO");
  lcd.setCursor(0,1); lcd.print("ADS1115: "); lcd.print(okADS ? "OK" : "ERRO");
  lcd.setCursor(0,2); lcd.print("PH Probe: "); lcd.print(okPH ? "OK" : "ERRO");
  lcd.setCursor(0,3); lcd.print("MENU p/ voltar");
  while (true) {
    if (readButtonPressed(PIN_BTN_MENU, lastBtnStateMenu, lastDebounceTimeMenu)) break;
    wdt_reset(); delay(10);
  }
}

// restart using watchdog (preserve EEPROM)
void doRebootNow() {
  lcd.clear(); lcdPrintCentered(1, "REINICIANDO...");
  delay(200);
  wdt_enable(WDTO_15MS);
  while (1) {}
}

// perform action: if PH < ideal => LED on; if PH > ideal => pump for cfg.pumpDurationMs
void performPHAdjustmentAction(float currentPH) {
  if (currentPH < cfg.phIdeal) {
    digitalWrite(PIN_LED_ALERT, HIGH);
    lcd.clear();
    lcd.setCursor(0,0); lcd.print("PH ABAIXO DO IDEAL");
    lcd.setCursor(0,1); lcd.print("PH: "); lcd.print(currentPH, 2);
    lcd.setCursor(0,2); lcd.print("Ideal: "); lcd.print(cfg.phIdeal, 2);
    // not blocking; LED will be turned off when PH returns
  } else {
    unsigned long now = millis();
    if (!pumpCooldown || (now - lastPumpActivatedMillis >= PUMP_COOLDOWN_MS)) {
      lcd.clear(); lcd.setCursor(0,0); lcd.print("AJUSTANDO PH...");
      unsigned long start = millis();
      digitalWrite(PIN_MOSFET_TRIG, HIGH);
      while (millis() - start < cfg.pumpDurationMs) {
        float pct = float(millis() - start) * 100.0f / float(max(1UL, cfg.pumpDurationMs));
        drawProgressBar(1, 0, 20, pct);
        wdt_reset();
        delay(20);
      }
      digitalWrite(PIN_MOSFET_TRIG, LOW);
      lastPumpActivatedMillis = millis();
      pumpCooldown = true;
      lcd.clear(); lcdPrintCentered(1, "AJUSTE COMPLETO");
      delay(700);
    } else {
      unsigned long remaining = PUMP_COOLDOWN_MS - (now - lastPumpActivatedMillis);
      lcd.clear();
      lcd.setCursor(0,0); lcd.print("Bomba em cooldown");
      lcd.setCursor(0,1); lcd.print("Rest (s): "); lcd.print(remaining / 1000UL);
      delay(900);
    }
  }
}

// ========================= SETUP =========================
void setup() {
  // pins
  pinMode(PIN_BTN_MENU, INPUT_PULLUP);
  pinMode(PIN_BTN_DOWN, INPUT_PULLUP);
  pinMode(PIN_BTN_UP, INPUT_PULLUP);
  pinMode(PIN_MOSFET_TRIG, OUTPUT);
  pinMode(PIN_LED_ALERT, OUTPUT);
  digitalWrite(PIN_MOSFET_TRIG, LOW);
  digitalWrite(PIN_LED_ALERT, LOW);

  Serial.begin(115200);
  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcdPrintCentered(0, "Inicializando...");

  // init i2c and ADS1115 robustly
  adsAvailable = false;
  Wire.begin();
  Serial.println("Tentando inicializar ADS1115 em 0x48...");
  if (ads.begin(ADS_ADDR_DEFAULT)) {
    adsAvailable = true;
    Serial.println("ADS1115 inicializado em 0x48");
  } else {
    Serial.println("Sem resposta em 0x48. Escaneando 0x48..0x4B...");
    uint8_t found = 0;
    for (uint8_t addr = 0x48; addr <= 0x4B; addr++) {
      Wire.beginTransmission(addr);
      uint8_t err = Wire.endTransmission();
      if (err == 0) {
        Serial.print("I2C device at 0x");
        Serial.println(addr, HEX);
        found = addr;
        if (ads.begin(addr)) {
          adsAvailable = true;
          Serial.print("ADS1115 iniciado em 0x"); Serial.println(addr, HEX);
          break;
        }
      }
    }
  }

  if (adsAvailable) {
    ads.setGain(GAIN_ONE); // ±4.096V -> LSB 0.125mV
  } else {
    lcd.clear();
    lcdPrintCentered(0, "Erro ADS1115!");
    lcd.setCursor(0,1); lcd.print("Verifique I2C/ADDR");
    Serial.println("Aviso: ADS1115 nao inicializado. Usando fallback analog.");
  }

  // ds18b20
  ds.begin();

  // load config
  loadConfig();

  // watchdog: enable 8s
  wdt_enable(WDTO_8S);

  // initialize sample buffer to avoid garbage
  for (uint8_t i = 0; i < NUM_SAMPLES; i++) samples_mV[i] = readADSmV_singleEnded();
  samplesFilled = true;
  sampleIndex = 0;
  lastSampleMillis = millis();
  lastInteractionMillis = millis();

  screen = SCR_MONITOR;
  screenEnteredMillis = millis();
  lcd.clear();
}

// ========================= MAIN LOOP =========================
void loop() {
  unsigned long now = millis();
  wdt_reset();

  // periodic sampling every 1s
  if (now - lastSampleMillis >= SAMPLE_INTERVAL_MS) {
    lastSampleMillis = now;
    float mV = readADSmV_singleEnded();
    samples_mV[sampleIndex] = mV;
    sampleIndex++;
    if (sampleIndex >= NUM_SAMPLES) {
      sampleIndex = 0;
      samplesFilled = true;
    }
    float tempC = readTemperatureC();
    if (isnan(tempC)) tempC = 25.0f;
    phInst = voltageToPH(mV, tempC);

    // update PH_ATUAL when buffer cycle is ready
    static unsigned long lastPhAtualUpdate = 0;
    if (samplesFilled && (now - lastPhAtualUpdate >= (NUM_SAMPLES * SAMPLE_INTERVAL_MS - 200))) {
      float bufferCopy[NUM_SAMPLES];
      for (uint8_t i = 0; i < NUM_SAMPLES; i++) bufferCopy[i] = samples_mV[i];
      float avg_mV = computeFilteredAverageFromArray(bufferCopy, NUM_SAMPLES);
      float tempC2 = readTemperatureC();
      if (isnan(tempC2)) tempC2 = 25.0f;
      float avgPH = voltageToPH(avg_mV, tempC2);
      phAtual = avgPH;
      lastPhAtualUpdate = now;

      // check for big variation (>0.3)
      if (fabs(phAtual - lastConfirmedPH) > PH_DELTA_ALERT) {
        // collect repeated averages until stable (3 in a row within PH_STABLE_THRESHOLD) or timeout
        float recent[10]; uint8_t count = 0;
        recent[count++] = phAtual;
        bool stable = false;
        for (uint8_t iter = 0; iter < 9; iter++) {
          // wait one sample interval and re-evaluate using current buffer
          unsigned long sstart = millis();
          while (millis() - sstart < SAMPLE_INTERVAL_MS) { wdt_reset(); delay(10); }
          // copy current buffer (non-blocking)
          float buffer2[NUM_SAMPLES];
          for (uint8_t i = 0; i < NUM_SAMPLES; i++) buffer2[i] = samples_mV[i];
          float avg_mV2 = computeFilteredAverageFromArray(buffer2, NUM_SAMPLES);
          float tnow = readTemperatureC(); if (isnan(tnow)) tnow = 25.0f;
          float newPH = voltageToPH(avg_mV2, tnow);
          for (int j = min((uint8_t)9, count); j > 0; j--) recent[j] = recent[j - 1];
          recent[0] = newPH;
          if (count < 10) count++;
          if (count >= 3) {
            if (fabs(recent[0] - recent[1]) <= PH_STABLE_THRESHOLD &&
                fabs(recent[1] - recent[2]) <= PH_STABLE_THRESHOLD) {
              stable = true;
              float combined = (recent[0] + recent[1] + recent[2]) / 3.0f;
              phAtual = combined;
              break;
            }
          }
        } // end iter
        if (!stable) {
          lastConfirmedPH = phAtual;
        } else {
          lastConfirmedPH = phAtual;
          performPHAdjustmentAction(phAtual);
        }
      } else {
        lastConfirmedPH = phAtual;
        if (phAtual >= cfg.phIdeal) digitalWrite(PIN_LED_ALERT, LOW);
      }
    } // end update PH_ATUAL
  } // end sample

  // read buttons
  bool pressedMenu = readButtonPressed(PIN_BTN_MENU, lastBtnStateMenu, lastDebounceTimeMenu);
  bool pressedDown = readButtonPressed(PIN_BTN_DOWN, lastBtnStateDown, lastDebounceTimeDown);
  bool pressedUp   = readButtonPressed(PIN_BTN_UP, lastBtnStateUp, lastDebounceTimeUp);
  if (pressedMenu || pressedDown || pressedUp) lastInteractionMillis = now;

  // screen state machine
  switch (screen) {
    case SCR_MONITOR:
      if (now - screenEnteredMillis > 250) {
        screenEnteredMillis = now;
        lcd.clear();
        showSpinner();
        lcd.setCursor(0,1); lcd.print("PH ATUAL: "); lcd.print(phAtual, 2);
        lcd.setCursor(0,2); lcd.print("PH INST: "); lcd.print(phInst, 2);
        lcd.setCursor(0,3);
        float t = readTemperatureC();
        if (isnan(t)) lcd.print("T: ??C "); else { lcd.print("T:"); lcd.print(t,1); lcd.print("C "); }
        lcd.print("| Ideal "); lcd.print(cfg.phIdeal,1);
      }
      if (pressedMenu) { screen = SCR_MENU_MAIN; screenEnteredMillis = now; delay(120); }
      break;

    case SCR_MENU_MAIN: {
      static int sel = 0;
      const char* items[] = { "Definir PH Ideal", "Calibrar Sonda", "Menu Tecnico", "Voltar" };
      const int nItems = 4;
      if (pressedUp) sel = (sel - 1 + nItems) % nItems;
      if (pressedDown) sel = (sel + 1) % nItems;
      if (now - screenEnteredMillis < 300) sel = 0;
      lcd.clear();
      lcd.setCursor(0,0); lcd.print("> "); lcd.print(items[sel]);
      lcd.setCursor(0,1); lcd.print("  "); lcd.print(items[(sel+1)%nItems]);
      lcd.setCursor(0,2); lcd.print("  "); lcd.print(items[(sel+2)%nItems]);
      lcd.setCursor(0,3); lcd.print("MENU p/ OK");
      if (pressedMenu) {
        if (sel == 0) { tempPHSetting = cfg.phIdeal; screen = SCR_SET_PH; }
        else if (sel == 1) { screen = SCR_CALIB_MENU; }
        else if (sel == 2) { screen = SCR_TECH_MENU; }
        else { screen = SCR_MONITOR; }
        screenEnteredMillis = now; delay(120);
      }
      if (now - lastInteractionMillis > INACTIVITY_TIMEOUT_MS) { screen = SCR_MONITOR; screenEnteredMillis = now; }
    } break;

    case SCR_SET_PH: {
      if (pressedUp) { tempPHSetting += 0.1f; if (tempPHSetting > 13.0f) tempPHSetting = 13.0f; }
      if (pressedDown) { tempPHSetting -= 0.1f; if (tempPHSetting < 1.0f) tempPHSetting = 1.0f; }
      lcd.clear();
      lcdPrintCentered(0, "DEFINIR PH IDEAL");
      lcd.setCursor(0,1); lcd.print("PH Ideal: "); lcd.print(tempPHSetting, 1);
      lcd.setCursor(0,2); lcd.print("MENU p/ salvar");
      lcd.setCursor(0,3); lcd.print("Inativo 30s descarta");
      if (pressedMenu) { cfg.phIdeal = tempPHSetting; saveConfig(); lcd.clear(); lcdPrintCentered(1, "Gravado"); delay(700); screen = SCR_MONITOR; screenEnteredMillis = now; }
      if (now - lastInteractionMillis > INACTIVITY_TIMEOUT_MS) { lcd.clear(); lcdPrintCentered(1, "Ajuste descartado"); delay(600); screen = SCR_MONITOR; screenEnteredMillis = now; }
    } break;

    case SCR_CALIB_MENU: {
      static int sel = 0;
      const char* items[] = { "1 PONTO", "2 PONTOS", "Voltar" };
      const int nItems = 3;
      if (pressedUp) sel = (sel - 1 + nItems) % nItems;
      if (pressedDown) sel = (sel + 1) % nItems;
      if (now - screenEnteredMillis < 200) sel = 0;
      lcd.clear();
      lcd.setCursor(0,0); lcd.print("> "); lcd.print(items[sel]);
      lcd.setCursor(0,1); lcd.print("  "); lcd.print(items[(sel+1)%nItems]);
      lcd.setCursor(0,2); lcd.print("  "); lcd.print(items[(sel+2)%nItems]);
      lcd.setCursor(0,3); lcd.print("Press MENU");
      if (pressedMenu) {
        if (sel == 0) screen = SCR_CALIB_1_SELECT;
        else if (sel == 1) screen = SCR_CALIB_2_FIRST;
        else screen = SCR_MONITOR;
        screenEnteredMillis = now; delay(120);
      }
      if (now - lastInteractionMillis > INACTIVITY_TIMEOUT_MS) { screen = SCR_MONITOR; screenEnteredMillis = now; }
    } break;

    case SCR_CALIB_1_SELECT: {
      float options[] = {4.01f, 7.01f, 10.1f};
      static int sel = 1;
      if (now - screenEnteredMillis < 200) sel = 1;
      if (pressedUp) sel = (sel - 1 + 3) % 3;
      if (pressedDown) sel = (sel + 1) % 3;
      lcd.clear();
      lcd.setCursor(0,0); lcd.print("CALIBRAR 1 PONTO");
      lcd.setCursor(0,1); lcd.print("> "); lcd.print(options[sel],2);
      lcd.setCursor(0,2); lcd.print("MENU p/ iniciar");
      lcd.setCursor(0,3); lcd.print("Voltar: MENU atras");
      if (pressedMenu) {
        bool ok = calibrateOnePoint(options[sel]);
        if (ok) { lcd.clear(); lcdPrintCentered(1, "CALIBRAGEM OK"); delay(700); screen = SCR_MONITOR; }
        else { screen = SCR_ERROR_CALIB; }
        screenEnteredMillis = now;
      }
      if (now - lastInteractionMillis > INACTIVITY_TIMEOUT_MS) { screen = SCR_MONITOR; screenEnteredMillis = now; }
    } break;

    case SCR_CALIB_2_FIRST: {
      float options[] = {4.01f, 7.01f, 10.1f};
      static int sel = 0;
      if (now - screenEnteredMillis < 200) sel = 0;
      if (pressedUp) sel = (sel - 1 + 3) % 3;
      if (pressedDown) sel = (sel + 1) % 3;
      lcd.clear();
      lcd.setCursor(0,0); lcd.print("CALIBRAR 2 PONTOS");
      lcd.setCursor(0,1); lcd.print("1o: "); lcd.print(options[sel],2);
      lcd.setCursor(0,2); lcd.print("MENU p/ OK");
      lcd.setCursor(0,3); lcd.print("Voltar: MENU");
      if (pressedMenu) { cfg.offset_mV = options[sel]; screen = SCR_CALIB_2_SECOND; screenEnteredMillis = now; } // reuse offset_mV temporarily
      if (now - lastInteractionMillis > INACTIVITY_TIMEOUT_MS) { screen = SCR_MONITOR; screenEnteredMillis = now; }
    } break;

    case SCR_CALIB_2_SECOND: {
      float firstPH = cfg.offset_mV;
      float options[] = {4.01f, 7.01f, 10.1f};
      float choices[2]; int idx = 0;
      for (int i = 0; i < 3; i++) if (fabs(options[i] - firstPH) > 0.001f) choices[idx++] = options[i];
      static int sel = 0;
      if (now - screenEnteredMillis < 200) sel = 0;
      if (pressedUp) sel = (sel - 1 + 2) % 2;
      if (pressedDown) sel = (sel + 1) % 2;
      lcd.clear();
      lcd.setCursor(0,0); lcd.print("Calib 2 Pontos");
      lcd.setCursor(0,1); lcd.print("1o: "); lcd.print(firstPH,2);
      lcd.setCursor(0,2); lcd.print("2o: "); lcd.print(choices[sel],2);
      lcd.setCursor(0,3); lcd.print("MENU p/ iniciar");
      if (pressedMenu) {
        bool ok = calibrateTwoPoints(firstPH, choices[sel]);
        if (ok) { lcd.clear(); lcdPrintCentered(1,"CALIB 2P OK"); delay(700); screen = SCR_MONITOR; }
        else screen = SCR_ERROR_CALIB;
        screenEnteredMillis = now;
      }
      if (now - lastInteractionMillis > INACTIVITY_TIMEOUT_MS) { screen = SCR_MONITOR; screenEnteredMillis = now; }
    } break;

    case SCR_ERROR_CALIB: {
      lcd.clear(); lcdPrintCentered(0, "ERRO DE CALIBRAGEM");
      lcd.setCursor(0,2); lcd.print("MENU: Tentar Novamente");
      lcd.setCursor(0,3); lcd.print("Voltar: MENU");
      if (pressedMenu) { screen = SCR_CALIB_MENU; screenEnteredMillis = now; }
      if (now - lastInteractionMillis > INACTIVITY_TIMEOUT_MS) { screen = SCR_MONITOR; screenEnteredMillis = now; }
    } break;

    case SCR_TECH_MENU: {
      static int sel = 0;
      const char* items[] = { "Valores Brutos", "Checar Sensores", "Tempo Bomba", "Reiniciar", "Voltar" };
      const int nItems = 5;
      if (now - screenEnteredMillis < 200) sel = 0;
      if (pressedUp) sel = (sel - 1 + nItems) % nItems;
      if (pressedDown) sel = (sel + 1) % nItems;
      lcd.clear();
      lcd.setCursor(0,0); lcd.print("> "); lcd.print(items[sel]);
      lcd.setCursor(0,1); lcd.print("  "); lcd.print(items[(sel+1)%nItems]);
      lcd.setCursor(0,2); lcd.print("  "); lcd.print(items[(sel+2)%nItems]);
      lcd.setCursor(0,3); lcd.print("MENU p/ OK");
      if (pressedMenu) {
        if (sel == 0) { screen = SCR_RAW_VALUES; }
        else if (sel == 1) { checkSensorsAndDisplay(); screen = SCR_TECH_MENU; }
        else if (sel == 2) {
          tempPumpSettingMs = cfg.pumpDurationMs;
          // interactive adjust loop
          bool done = false;
          unsigned long lastInter = millis();
          while (!done) {
            wdt_reset();
            lcd.clear();
            lcd.setCursor(0,0); lcd.print("Pump ms: "); lcd.print(tempPumpSettingMs);
            lcd.setCursor(0,1); lcd.print("UP/DOWN +/-100ms");
            lcd.setCursor(0,2); lcd.print("MENU: salvar");
            lcd.setCursor(0,3); lcd.print("Voltar inativo 30s");
            // read buttons
            bool upb = readButtonPressed(PIN_BTN_UP, lastBtnStateUp, lastDebounceTimeUp);
            bool downb = readButtonPressed(PIN_BTN_DOWN, lastBtnStateDown, lastDebounceTimeDown);
            bool menub = readButtonPressed(PIN_BTN_MENU, lastBtnStateMenu, lastDebounceTimeMenu);
            if (upb) { tempPumpSettingMs += 100; if (tempPumpSettingMs > 20000UL) tempPumpSettingMs = 20000UL; lastInter = millis(); }
            if (downb) { if (tempPumpSettingMs >= 100) tempPumpSettingMs -= 100; else tempPumpSettingMs = 0; lastInter = millis(); }
            if (menub) {
              cfg.pumpDurationMs = tempPumpSettingMs; saveConfig();
              lcd.clear(); lcdPrintCentered(1, "Tempo salvo"); delay(700);
              done = true;
            }
            if (millis() - lastInter > INACTIVITY_TIMEOUT_MS) done = true;
            delay(120);
          }
          screen = SCR_TECH_MENU;
        }
        else if (sel == 3) { screen = SCR_CONFIRM_REBOOT; }
        else { screen = SCR_MONITOR; }
        screenEnteredMillis = now;
      }
      if (now - lastInteractionMillis > INACTIVITY_TIMEOUT_MS) { screen = SCR_MONITOR; screenEnteredMillis = now; }
    } break;

    case SCR_RAW_VALUES: {
      lcd.clear(); lcdPrintCentered(0, "VALORES BRUTOS");
      float volt = readADSmV_singleEnded();
      lcd.setCursor(0,1); lcd.print("Tensao(mV): "); lcd.print(volt, 2);
      lcd.setCursor(0,2); lcd.print("Slope(mV/pH): "); lcd.print(cfg.slope_mV_per_pH, 3);
      lcd.setCursor(0,3); lcd.print("MENU p/ voltar");
      if (pressedMenu) { screen = SCR_TECH_MENU; screenEnteredMillis = now; }
      if (now - lastInteractionMillis > INACTIVITY_TIMEOUT_MS) { screen = SCR_MONITOR; screenEnteredMillis = now; }
    } break;

    case SCR_CONFIRM_REBOOT: {
      lcd.clear(); lcdPrintCentered(0, "REINICIAR SISTEMA?");
      lcd.setCursor(0,2); lcd.print("MENU: SIM  DOWN: NAO");
      if (pressedMenu) doRebootNow();
      if (pressedDown) { screen = SCR_TECH_MENU; screenEnteredMillis = now; }
    } break;

    default:
      screen = SCR_MONITOR;
      screenEnteredMillis = now;
      break;
  } // end screen switch

  // LED off if PH back to normal
  if (digitalRead(PIN_LED_ALERT) == HIGH && phAtual >= cfg.phIdeal) digitalWrite(PIN_LED_ALERT, LOW);

  // global timeout back to monitor
  if (screen != SCR_MONITOR && (millis() - lastInteractionMillis > INACTIVITY_TIMEOUT_MS)) {
    screen = SCR_MONITOR;
    screenEnteredMillis = millis();
  }

  wdt_reset();
  delay(10); // small yield acceptable
}
