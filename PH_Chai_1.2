/*
 ================================================================================================
 == CONTROLADOR AUTOM√ÅTICO DE PH - ARDUINO NANO                                                ==
 ================================================================================================
 Autor: Rafa (ajudado pelo Chai üòé)
 Data: 2025-09-29

 Descri√ß√£o:
 Sistema para monitorar e ajustar o pH em cultivo indoor, com bomba perist√°ltica 5V,
 ajuste autom√°tico de pH, menus em LCD 20x4, EEPROM para salvar calibra√ß√£o e pH ideal.
 -----------------------------------------------------------------------------------------------
 Componentes principais:
 - Arduino Nano 5V
 - ADS1115 (I2C)
 - Sonda de pH + m√≥dulo anal√≥gico
 - Sensor DS18B20 (temperatura com sonda)
 - Tela LCD 20x4 I2C
 - M√≥dulo MOSFET 15A + bomba perist√°ltica 5V
 - Bot√µes touch (MENU, UP, DOWN)
 - LED indicador 3V
 ================================================================================================
*/

// ============================ BIBLIOTECAS ============================
#include <Wire.h>
#include <EEPROM.h>
#include <LiquidCrystal_I2C.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Adafruit_ADS1X15.h>
#include <avr/wdt.h>

// ============================ DEFINI√á√ïES ============================
#define ADS_ADDRESS 0x48          // Endere√ßo padr√£o do ADS1115
#define DS18B20_PIN 2             // Pino do sensor de temperatura
#define BTN_MENU    3
#define BTN_DOWN    4
#define BTN_UP      5
#define MOSFET_PIN  6
#define LED_PIN     7

#define EEPROM_PH_IDEAL_ADDR 0    // endere√ßo na EEPROM para salvar pH ideal
#define EEPROM_CALIB_ADDR    10   // endere√ßo na EEPROM para salvar calibra√ß√£o

// constantes do ADS1115
#define ADS1115_LSB_V 0.000125F   // 0.125mV por bit @ GAIN_ONE

// ============================ OBJETOS ============================
LiquidCrystal_I2C lcd(0x27, 20, 4);
OneWire oneWire(DS18B20_PIN);
DallasTemperature sensors(&oneWire);
Adafruit_ADS1115 ads;

// ============================ VARI√ÅVEIS GLOBAIS ============================
bool adsAvailable = false;        // flag para indicar se ADS foi inicializado
float phIdeal = 7.0;              // valor padr√£o de pH ideal
float phSlope = 1.0;              // slope da calibra√ß√£o
float phOffset = 0.0;             // offset da calibra√ß√£o

unsigned long lastPumpAction = 0; // controle de tempo entre ajustes da bomba
unsigned long pumpInterval = 300000; // 5 minutos (ajust√°vel no menu t√©cnico)
unsigned long lastMenuAction = 0; // timeout de menu (30s)

// ============================ FUN√á√ïES AUXILIARES ============================

// Escreve string centralizada no LCD em uma linha
void lcdPrintCentered(uint8_t row, String text) {
  lcd.setCursor((20 - text.length())/2, row);
  lcd.print(text);
}

// Ler dados crus do ADS ou fallback
float readADSmV_singleEnded() {
  if (adsAvailable) {
    int16_t raw = ads.readADC_SingleEnded(0);
    float volts = raw * ADS1115_LSB_V; 
    return volts * 1000.0f; // mV
  } else {
    // fallback: usa A0 caso ADS falhe
    int raw = analogRead(A0);
    return (raw / 1023.0f) * 5000.0f;
  }
}

// Leitura de temperatura (¬∫C)
float readTemperature() {
  sensors.requestTemperatures();
  return sensors.getTempCByIndex(0);
}

// Converte leitura mV para pH usando calibra√ß√£o
float mvToPH(float mV, float tempC) {
  // compensa√ß√£o simples: slope e offset
  return (mV * phSlope) + phOffset;
}

// ============================ EEPROM ============================
void loadSettings() {
  EEPROM.get(EEPROM_PH_IDEAL_ADDR, phIdeal);
  if (isnan(phIdeal) || phIdeal < 1.0 || phIdeal > 13.0) phIdeal = 7.0;

  EEPROM.get(EEPROM_CALIB_ADDR, phSlope);
  EEPROM.get(EEPROM_CALIB_ADDR+4, phOffset);
  if (isnan(phSlope) || phSlope == 0) phSlope = 1.0;
  if (isnan(phOffset)) phOffset = 0.0;
}

void saveSettings() {
  EEPROM.put(EEPROM_PH_IDEAL_ADDR, phIdeal);
  EEPROM.put(EEPROM_CALIB_ADDR, phSlope);
  EEPROM.put(EEPROM_CALIB_ADDR+4, phOffset);
}

// ============================ SETUP ============================
void setup() {
  // Serial para debug
  Serial.begin(115200);

  // LCD
  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcdPrintCentered(0, "Inicializando...");

  // pinos
  pinMode(BTN_MENU, INPUT);
  pinMode(BTN_DOWN, INPUT);
  pinMode(BTN_UP, INPUT);
  pinMode(MOSFET_PIN, OUTPUT);
  pinMode(LED_PIN, OUTPUT);

  // sensores
  sensors.begin();

  // tenta inicializar ADS1115
  adsAvailable = false;
  Wire.begin();
  Serial.println("Tentando inicializar ADS1115 em 0x48...");
  if (ads.begin(ADS_ADDRESS)) {
    adsAvailable = true;
    Serial.println("ADS1115 inicializado em 0x48");
  } else {
    Serial.println("Falha em 0x48. Escaneando enderecos...");
    for (uint8_t addr=0x48; addr<=0x4B; addr++) {
      Wire.beginTransmission(addr);
      if (Wire.endTransmission()==0) {
        Serial.print("Dispositivo encontrado em 0x");
        Serial.println(addr, HEX);
        if (ads.begin(addr)) {
          adsAvailable = true;
          Serial.println("ADS1115 inicializado neste endereco.");
          break;
        }
      }
    }
  }

  if (adsAvailable) {
    ads.setGain(GAIN_ONE);
  } else {
    lcd.clear();
    lcdPrintCentered(0, "Erro ADS1115!");
    lcd.setCursor(0,1);
    lcd.print("Fallback A0 ativo");
    Serial.println("Aviso: ADS1115 nao inicializado, usando fallback A0.");
  }

  // carrega configs
  loadSettings();

  // watchdog 2s
  wdt_enable(WDTO_2S);

  lcd.clear();
  lcdPrintCentered(0, "Sistema Pronto");
  delay(1500);
  lcd.clear();
}

// ============================ LOOP ============================
void loop() {
  wdt_reset();

  // leitura de temperatura
  float tempC = readTemperature();

  // leitura de pH
  float mV = readADSmV_singleEnded();
  float ph = mvToPH(mV, tempC);

  // exibe dados principais
  lcd.setCursor(0,0); lcd.print("PH ATUAL: "); lcd.print(ph,1);
  lcd.setCursor(0,1); lcd.print("Temp: "); lcd.print(tempC,1); lcd.print("C");
  lcd.setCursor(0,2); lcd.print("PH IDEAL: "); lcd.print(phIdeal,1);

  // controle simples da bomba
  if (ph > phIdeal+0.1 && millis()-lastPumpAction > pumpInterval) {
    lcd.setCursor(0,3); lcd.print("Ajustando PH...  ");
    digitalWrite(MOSFET_PIN, HIGH);
    delay(1000); // 1s de bomba
    digitalWrite(MOSFET_PIN, LOW);
    lastPumpAction = millis();
    lcd.setCursor(0,3); lcd.print("Ajuste completo  ");
  } else if (ph < phIdeal-0.1) {
    digitalWrite(LED_PIN, HIGH);
    lcd.setCursor(0,3); lcd.print("PH abaixo ideal  ");
  } else {
    digitalWrite(LED_PIN, LOW);
    lcd.setCursor(0,3); lcd.print("                ");
  }

  delay(1000); // atualiza√ß√£o da tela
}
